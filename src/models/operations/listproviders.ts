/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * A Problem Details object (RFC 9457).
 *
 * @remarks
 *
 * Additional properties specific to the problem type may be present.
 */
export type ListProvidersAPIProblem = {
  /**
   * An absolute URI that identifies the problem type
   */
  type?: string | undefined;
  /**
   * An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
   */
  href?: string | undefined;
  /**
   * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
   */
  title?: string | undefined;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   */
  status?: number | undefined;
  /**
   * A human-readable explanation specific to this occurrence of the problem
   */
  detail?: string | undefined;
  /**
   * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   */
  instance?: string | undefined;
  /**
   * The subsystem that generated the problem
   */
  subsystem?: string | undefined;
  /**
   * The time the problem occurred, formatted as RFC-3339
   */
  time?: Date | undefined;
  /**
   * A unique identifier for the request, useful for debugging
   */
  requestId?: string | undefined;
  /**
   * A list of problems that caused this problem. This can be used to represent multiple
   *
   * @remarks
   * root causes. There is no guaranteed ordering of the causes.
   */
  causes?: Array<string> | undefined;
  /**
   * A brief description of how to resolve the problem
   */
  remedy?: string | undefined;
  /**
   * An email address to contact for support
   */
  supportEmail?: string | undefined;
  /**
   * A phone number to contact for support
   */
  supportPhone?: string | undefined;
  /**
   * A URL to contact for support
   */
  supportUrl?: string | undefined;
  /**
   * Whether the request can be retried
   */
  retryable?: boolean | undefined;
  /**
   * A timestamp after which the request can be retried, formatted as RFC-3339
   */
  retryAfter?: Date | undefined;
  /**
   * Additional context for the problem
   */
  context?: { [k: string]: any } | undefined;
};

/**
 * The type of authentication required by the provider.
 */
export const AuthType = {
  Oauth2: "oauth2",
  ApiKey: "apiKey",
  Basic: "basic",
  Jwt: "jwt",
  None: "none",
} as const;
/**
 * The type of authentication required by the provider.
 */
export type AuthType = ClosedEnum<typeof AuthType>;

export const GrantType = {
  AuthorizationCode: "authorizationCode",
  AuthorizationCodePKCE: "authorizationCodePKCE",
  ClientCredentials: "clientCredentials",
  Password: "password",
} as const;
export type GrantType = ClosedEnum<typeof GrantType>;

/**
 * Fields to be used to extract token metadata from the token response.
 */
export type TokenMetadataFields = {
  workspaceRefField?: string | undefined;
  consumerRefField?: string | undefined;
  scopesField?: string | undefined;
};

/**
 * Configuration for OAuth2.0. Must be provided if authType is oauth2.
 */
export type OAuth2Options = {
  grantType: GrantType;
  /**
   * The authorization URL.
   */
  authURL?: string | undefined;
  /**
   * The token URL.
   */
  tokenURL: string;
  /**
   * Whether scopes are required to be known ahead of the OAuth flow.
   */
  explicitScopesRequired: boolean;
  /**
   * Whether the workspace is required to be known ahead of the OAuth flow.
   */
  explicitWorkspaceRequired: boolean;
  /**
   * A list of URLs that represent the audience for the token, which is needed for some client credential grant flows.
   */
  audience?: Array<string> | undefined;
  /**
   * Fields to be used to extract token metadata from the token response.
   */
  tokenMetadataFields: TokenMetadataFields;
  /**
   * URL with more information about where to retrieve Client ID and Client Secret, etc.
   */
  docsURL?: string | undefined;
  authURLParams?: { [k: string]: string } | undefined;
};

/**
 * How the API key should be attached to requests.
 */
export const AttachmentType = {
  Query: "query",
  Header: "header",
} as const;
/**
 * How the API key should be attached to requests.
 */
export type AttachmentType = ClosedEnum<typeof AttachmentType>;

/**
 * Configuration for API key in query parameter. Must be provided if type is in-query.
 */
export type APIKeyQueryOptions = {
  /**
   * The name of the query parameter to be used for the API key.
   */
  name: string;
};

/**
 * Configuration for API key in header. Must be provided if type is in-header.
 */
export type APIKeyHeaderOptions = {
  /**
   * The name of the header to be used for the API key.
   */
  name: string;
  /**
   * The prefix to be added to the API key value when it is sent in the header.
   */
  valuePrefix?: string | undefined;
};

/**
 * Configuration for API key. Must be provided if authType is apiKey.
 */
export type APIKeyOptions = {
  /**
   * How the API key should be attached to requests.
   */
  attachmentType: AttachmentType;
  /**
   * Configuration for API key in query parameter. Must be provided if type is in-query.
   */
  query?: APIKeyQueryOptions | undefined;
  /**
   * Configuration for API key in header. Must be provided if type is in-header.
   */
  header?: APIKeyHeaderOptions | undefined;
  /**
   * URL with more information about how to get or use an API key.
   */
  docsURL?: string | undefined;
};

/**
 * whether the API key should be used as the username or password.
 */
export const FieldUsed = {
  Username: "username",
  Password: "password",
} as const;
/**
 * whether the API key should be used as the username or password.
 */
export type FieldUsed = ClosedEnum<typeof FieldUsed>;

/**
 * when this object is present, it means that this provider uses Basic Auth to actually collect an API key
 */
export type APIKeyAsBasicOptions = {
  /**
   * whether the API key should be used as the username or password.
   */
  fieldUsed?: FieldUsed | undefined;
  /**
   * How to transform the API key in to a basic auth user:pass string. The %s is replaced with the API key value.
   */
  keyFormat?: string | undefined;
};

/**
 * Configuration for Basic Auth. Optional.
 */
export type BasicAuthOptions = {
  /**
   * If true, the provider uses an API key which then gets encoded as a basic auth user:pass string.
   */
  apiKeyAsBasic?: boolean | undefined;
  /**
   * when this object is present, it means that this provider uses Basic Auth to actually collect an API key
   */
  apiKeyAsBasicOpts?: APIKeyAsBasicOptions | undefined;
  /**
   * URL with more information about how to get or use an API key.
   */
  docsURL?: string | undefined;
};

export type BulkWriteSupport = {
  insert: boolean;
  update: boolean;
  upsert: boolean;
  delete: boolean;
};

export type SubscribeSupport = {
  create?: boolean | undefined;
  update?: boolean | undefined;
  delete?: boolean | undefined;
  passThrough?: boolean | undefined;
};

/**
 * The supported features for the provider.
 */
export type Support = {
  bulkWrite: BulkWriteSupport;
  proxy: boolean;
  read: boolean;
  subscribe: boolean;
  write: boolean;
  subscribeSupport?: SubscribeSupport | undefined;
};

/**
 * Media for light/regular mode.
 */
export type MediaTypeRegular = {
  /**
   * URL to the icon for the provider.
   */
  iconURL?: string | undefined;
  /**
   * URL to the logo for the provider.
   */
  logoURL?: string | undefined;
};

/**
 * Media to be used in dark mode.
 */
export type MediaTypeDarkMode = {
  /**
   * URL to the icon for the provider that is to be used in dark mode.
   */
  iconURL?: string | undefined;
  /**
   * URL to the logo for the provider that is to be used in dark mode.
   */
  logoURL?: string | undefined;
};

export type Media = {
  /**
   * Media for light/regular mode.
   */
  regular?: MediaTypeRegular | undefined;
  /**
   * Media to be used in dark mode.
   */
  darkMode?: MediaTypeDarkMode | undefined;
};

/**
 * The scope of the subscription.
 */
export const SubscriptionScope = {
  Integration: "integration",
  Installation: "installation",
} as const;
/**
 * The scope of the subscription.
 */
export type SubscriptionScope = ClosedEnum<typeof SubscriptionScope>;

/**
 * The scope of the target URL.
 */
export const TargetURLScope = {
  Integration: "integration",
  Installation: "installation",
} as const;
/**
 * The scope of the target URL.
 */
export type TargetURLScope = ClosedEnum<typeof TargetURLScope>;

/**
 * The timing of the registration.
 */
export const RegistrationTiming = {
  ProviderApp: "providerApp",
  Integration: "integration",
  Installation: "installation",
} as const;
/**
 * The timing of the registration.
 */
export type RegistrationTiming = ClosedEnum<typeof RegistrationTiming>;

export type SubscribeOptions = {
  /**
   * The scope of the subscription.
   */
  subscriptionScope: SubscriptionScope;
  /**
   * The scope of the target URL.
   */
  targetURLScope: TargetURLScope;
  /**
   * The timing of the registration.
   */
  registrationTiming: RegistrationTiming;
};

export type ListProvidersBulkWriteSupport = {
  insert: boolean;
  update: boolean;
  upsert: boolean;
  delete: boolean;
};

export type ListProvidersSubscribeSupport = {
  create?: boolean | undefined;
  update?: boolean | undefined;
  delete?: boolean | undefined;
  passThrough?: boolean | undefined;
};

/**
 * The supported features for the provider.
 */
export type ListProvidersSupport = {
  bulkWrite: ListProvidersBulkWriteSupport;
  proxy: boolean;
  read: boolean;
  subscribe: boolean;
  write: boolean;
  subscribeSupport?: ListProvidersSubscribeSupport | undefined;
};

export type ModuleInfo = {
  displayName: string;
  baseURL: string;
  /**
   * The supported features for the provider.
   */
  support: ListProvidersSupport;
};

export type ProviderInfo = {
  name: string;
  /**
   * The type of authentication required by the provider.
   */
  authType: AuthType;
  /**
   * The base URL for making API requests.
   */
  baseURL: string;
  /**
   * Configuration for OAuth2.0. Must be provided if authType is oauth2.
   */
  oauth2Opts?: OAuth2Options | undefined;
  /**
   * Configuration for API key. Must be provided if authType is apiKey.
   */
  apiKeyOpts?: APIKeyOptions | undefined;
  /**
   * Configuration for Basic Auth. Optional.
   */
  basicOpts?: BasicAuthOptions | undefined;
  /**
   * The supported features for the provider.
   */
  support: Support;
  /**
   * Additional provider-specific metadata.
   */
  providerOpts: { [k: string]: string };
  /**
   * The display name of the provider, if omitted, defaults to provider name.
   */
  displayName?: string | undefined;
  /**
   * If true, we require additional information after auth to start making requests.
   */
  postAuthInfoNeeded?: boolean | undefined;
  media?: Media | undefined;
  labels?: { [k: string]: string } | undefined;
  subscribeOpts?: SubscribeOptions | undefined;
  /**
   * The registry of provider modules.
   */
  modules?: { [k: string]: ModuleInfo } | undefined;
};

export type ListProvidersResponse = ListProvidersAPIProblem | {
  [k: string]: ProviderInfo;
};

/** @internal */
export const ListProvidersAPIProblem$inboundSchema: z.ZodType<
  ListProvidersAPIProblem,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  context: z.record(z.any()).optional(),
});

/** @internal */
export type ListProvidersAPIProblem$Outbound = {
  type: string;
  href?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  subsystem?: string | undefined;
  time?: string | undefined;
  requestId?: string | undefined;
  causes?: Array<string> | undefined;
  remedy?: string | undefined;
  supportEmail?: string | undefined;
  supportPhone?: string | undefined;
  supportUrl?: string | undefined;
  retryable?: boolean | undefined;
  retryAfter?: string | undefined;
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const ListProvidersAPIProblem$outboundSchema: z.ZodType<
  ListProvidersAPIProblem$Outbound,
  z.ZodTypeDef,
  ListProvidersAPIProblem
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.date().transform(v => v.toISOString()).optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.date().transform(v => v.toISOString()).optional(),
  context: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersAPIProblem$ {
  /** @deprecated use `ListProvidersAPIProblem$inboundSchema` instead. */
  export const inboundSchema = ListProvidersAPIProblem$inboundSchema;
  /** @deprecated use `ListProvidersAPIProblem$outboundSchema` instead. */
  export const outboundSchema = ListProvidersAPIProblem$outboundSchema;
  /** @deprecated use `ListProvidersAPIProblem$Outbound` instead. */
  export type Outbound = ListProvidersAPIProblem$Outbound;
}

export function listProvidersAPIProblemToJSON(
  listProvidersAPIProblem: ListProvidersAPIProblem,
): string {
  return JSON.stringify(
    ListProvidersAPIProblem$outboundSchema.parse(listProvidersAPIProblem),
  );
}

export function listProvidersAPIProblemFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersAPIProblem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersAPIProblem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersAPIProblem' from JSON`,
  );
}

/** @internal */
export const AuthType$inboundSchema: z.ZodNativeEnum<typeof AuthType> = z
  .nativeEnum(AuthType);

/** @internal */
export const AuthType$outboundSchema: z.ZodNativeEnum<typeof AuthType> =
  AuthType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthType$ {
  /** @deprecated use `AuthType$inboundSchema` instead. */
  export const inboundSchema = AuthType$inboundSchema;
  /** @deprecated use `AuthType$outboundSchema` instead. */
  export const outboundSchema = AuthType$outboundSchema;
}

/** @internal */
export const GrantType$inboundSchema: z.ZodNativeEnum<typeof GrantType> = z
  .nativeEnum(GrantType);

/** @internal */
export const GrantType$outboundSchema: z.ZodNativeEnum<typeof GrantType> =
  GrantType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GrantType$ {
  /** @deprecated use `GrantType$inboundSchema` instead. */
  export const inboundSchema = GrantType$inboundSchema;
  /** @deprecated use `GrantType$outboundSchema` instead. */
  export const outboundSchema = GrantType$outboundSchema;
}

/** @internal */
export const TokenMetadataFields$inboundSchema: z.ZodType<
  TokenMetadataFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  workspaceRefField: z.string().optional(),
  consumerRefField: z.string().optional(),
  scopesField: z.string().optional(),
});

/** @internal */
export type TokenMetadataFields$Outbound = {
  workspaceRefField?: string | undefined;
  consumerRefField?: string | undefined;
  scopesField?: string | undefined;
};

/** @internal */
export const TokenMetadataFields$outboundSchema: z.ZodType<
  TokenMetadataFields$Outbound,
  z.ZodTypeDef,
  TokenMetadataFields
> = z.object({
  workspaceRefField: z.string().optional(),
  consumerRefField: z.string().optional(),
  scopesField: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TokenMetadataFields$ {
  /** @deprecated use `TokenMetadataFields$inboundSchema` instead. */
  export const inboundSchema = TokenMetadataFields$inboundSchema;
  /** @deprecated use `TokenMetadataFields$outboundSchema` instead. */
  export const outboundSchema = TokenMetadataFields$outboundSchema;
  /** @deprecated use `TokenMetadataFields$Outbound` instead. */
  export type Outbound = TokenMetadataFields$Outbound;
}

export function tokenMetadataFieldsToJSON(
  tokenMetadataFields: TokenMetadataFields,
): string {
  return JSON.stringify(
    TokenMetadataFields$outboundSchema.parse(tokenMetadataFields),
  );
}

export function tokenMetadataFieldsFromJSON(
  jsonString: string,
): SafeParseResult<TokenMetadataFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TokenMetadataFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TokenMetadataFields' from JSON`,
  );
}

/** @internal */
export const OAuth2Options$inboundSchema: z.ZodType<
  OAuth2Options,
  z.ZodTypeDef,
  unknown
> = z.object({
  grantType: GrantType$inboundSchema,
  authURL: z.string().optional(),
  tokenURL: z.string(),
  explicitScopesRequired: z.boolean(),
  explicitWorkspaceRequired: z.boolean(),
  audience: z.array(z.string()).optional(),
  tokenMetadataFields: z.lazy(() => TokenMetadataFields$inboundSchema),
  docsURL: z.string().optional(),
  authURLParams: z.record(z.string()).optional(),
});

/** @internal */
export type OAuth2Options$Outbound = {
  grantType: string;
  authURL?: string | undefined;
  tokenURL: string;
  explicitScopesRequired: boolean;
  explicitWorkspaceRequired: boolean;
  audience?: Array<string> | undefined;
  tokenMetadataFields: TokenMetadataFields$Outbound;
  docsURL?: string | undefined;
  authURLParams?: { [k: string]: string } | undefined;
};

/** @internal */
export const OAuth2Options$outboundSchema: z.ZodType<
  OAuth2Options$Outbound,
  z.ZodTypeDef,
  OAuth2Options
> = z.object({
  grantType: GrantType$outboundSchema,
  authURL: z.string().optional(),
  tokenURL: z.string(),
  explicitScopesRequired: z.boolean(),
  explicitWorkspaceRequired: z.boolean(),
  audience: z.array(z.string()).optional(),
  tokenMetadataFields: z.lazy(() => TokenMetadataFields$outboundSchema),
  docsURL: z.string().optional(),
  authURLParams: z.record(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OAuth2Options$ {
  /** @deprecated use `OAuth2Options$inboundSchema` instead. */
  export const inboundSchema = OAuth2Options$inboundSchema;
  /** @deprecated use `OAuth2Options$outboundSchema` instead. */
  export const outboundSchema = OAuth2Options$outboundSchema;
  /** @deprecated use `OAuth2Options$Outbound` instead. */
  export type Outbound = OAuth2Options$Outbound;
}

export function oAuth2OptionsToJSON(oAuth2Options: OAuth2Options): string {
  return JSON.stringify(OAuth2Options$outboundSchema.parse(oAuth2Options));
}

export function oAuth2OptionsFromJSON(
  jsonString: string,
): SafeParseResult<OAuth2Options, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OAuth2Options$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OAuth2Options' from JSON`,
  );
}

/** @internal */
export const AttachmentType$inboundSchema: z.ZodNativeEnum<
  typeof AttachmentType
> = z.nativeEnum(AttachmentType);

/** @internal */
export const AttachmentType$outboundSchema: z.ZodNativeEnum<
  typeof AttachmentType
> = AttachmentType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AttachmentType$ {
  /** @deprecated use `AttachmentType$inboundSchema` instead. */
  export const inboundSchema = AttachmentType$inboundSchema;
  /** @deprecated use `AttachmentType$outboundSchema` instead. */
  export const outboundSchema = AttachmentType$outboundSchema;
}

/** @internal */
export const APIKeyQueryOptions$inboundSchema: z.ZodType<
  APIKeyQueryOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});

/** @internal */
export type APIKeyQueryOptions$Outbound = {
  name: string;
};

/** @internal */
export const APIKeyQueryOptions$outboundSchema: z.ZodType<
  APIKeyQueryOptions$Outbound,
  z.ZodTypeDef,
  APIKeyQueryOptions
> = z.object({
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace APIKeyQueryOptions$ {
  /** @deprecated use `APIKeyQueryOptions$inboundSchema` instead. */
  export const inboundSchema = APIKeyQueryOptions$inboundSchema;
  /** @deprecated use `APIKeyQueryOptions$outboundSchema` instead. */
  export const outboundSchema = APIKeyQueryOptions$outboundSchema;
  /** @deprecated use `APIKeyQueryOptions$Outbound` instead. */
  export type Outbound = APIKeyQueryOptions$Outbound;
}

export function apiKeyQueryOptionsToJSON(
  apiKeyQueryOptions: APIKeyQueryOptions,
): string {
  return JSON.stringify(
    APIKeyQueryOptions$outboundSchema.parse(apiKeyQueryOptions),
  );
}

export function apiKeyQueryOptionsFromJSON(
  jsonString: string,
): SafeParseResult<APIKeyQueryOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => APIKeyQueryOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'APIKeyQueryOptions' from JSON`,
  );
}

/** @internal */
export const APIKeyHeaderOptions$inboundSchema: z.ZodType<
  APIKeyHeaderOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  valuePrefix: z.string().optional(),
});

/** @internal */
export type APIKeyHeaderOptions$Outbound = {
  name: string;
  valuePrefix?: string | undefined;
};

/** @internal */
export const APIKeyHeaderOptions$outboundSchema: z.ZodType<
  APIKeyHeaderOptions$Outbound,
  z.ZodTypeDef,
  APIKeyHeaderOptions
> = z.object({
  name: z.string(),
  valuePrefix: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace APIKeyHeaderOptions$ {
  /** @deprecated use `APIKeyHeaderOptions$inboundSchema` instead. */
  export const inboundSchema = APIKeyHeaderOptions$inboundSchema;
  /** @deprecated use `APIKeyHeaderOptions$outboundSchema` instead. */
  export const outboundSchema = APIKeyHeaderOptions$outboundSchema;
  /** @deprecated use `APIKeyHeaderOptions$Outbound` instead. */
  export type Outbound = APIKeyHeaderOptions$Outbound;
}

export function apiKeyHeaderOptionsToJSON(
  apiKeyHeaderOptions: APIKeyHeaderOptions,
): string {
  return JSON.stringify(
    APIKeyHeaderOptions$outboundSchema.parse(apiKeyHeaderOptions),
  );
}

export function apiKeyHeaderOptionsFromJSON(
  jsonString: string,
): SafeParseResult<APIKeyHeaderOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => APIKeyHeaderOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'APIKeyHeaderOptions' from JSON`,
  );
}

/** @internal */
export const APIKeyOptions$inboundSchema: z.ZodType<
  APIKeyOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  attachmentType: AttachmentType$inboundSchema,
  query: z.lazy(() => APIKeyQueryOptions$inboundSchema).optional(),
  header: z.lazy(() => APIKeyHeaderOptions$inboundSchema).optional(),
  docsURL: z.string().optional(),
});

/** @internal */
export type APIKeyOptions$Outbound = {
  attachmentType: string;
  query?: APIKeyQueryOptions$Outbound | undefined;
  header?: APIKeyHeaderOptions$Outbound | undefined;
  docsURL?: string | undefined;
};

/** @internal */
export const APIKeyOptions$outboundSchema: z.ZodType<
  APIKeyOptions$Outbound,
  z.ZodTypeDef,
  APIKeyOptions
> = z.object({
  attachmentType: AttachmentType$outboundSchema,
  query: z.lazy(() => APIKeyQueryOptions$outboundSchema).optional(),
  header: z.lazy(() => APIKeyHeaderOptions$outboundSchema).optional(),
  docsURL: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace APIKeyOptions$ {
  /** @deprecated use `APIKeyOptions$inboundSchema` instead. */
  export const inboundSchema = APIKeyOptions$inboundSchema;
  /** @deprecated use `APIKeyOptions$outboundSchema` instead. */
  export const outboundSchema = APIKeyOptions$outboundSchema;
  /** @deprecated use `APIKeyOptions$Outbound` instead. */
  export type Outbound = APIKeyOptions$Outbound;
}

export function apiKeyOptionsToJSON(apiKeyOptions: APIKeyOptions): string {
  return JSON.stringify(APIKeyOptions$outboundSchema.parse(apiKeyOptions));
}

export function apiKeyOptionsFromJSON(
  jsonString: string,
): SafeParseResult<APIKeyOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => APIKeyOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'APIKeyOptions' from JSON`,
  );
}

/** @internal */
export const FieldUsed$inboundSchema: z.ZodNativeEnum<typeof FieldUsed> = z
  .nativeEnum(FieldUsed);

/** @internal */
export const FieldUsed$outboundSchema: z.ZodNativeEnum<typeof FieldUsed> =
  FieldUsed$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FieldUsed$ {
  /** @deprecated use `FieldUsed$inboundSchema` instead. */
  export const inboundSchema = FieldUsed$inboundSchema;
  /** @deprecated use `FieldUsed$outboundSchema` instead. */
  export const outboundSchema = FieldUsed$outboundSchema;
}

/** @internal */
export const APIKeyAsBasicOptions$inboundSchema: z.ZodType<
  APIKeyAsBasicOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  fieldUsed: FieldUsed$inboundSchema.optional(),
  keyFormat: z.string().optional(),
});

/** @internal */
export type APIKeyAsBasicOptions$Outbound = {
  fieldUsed?: string | undefined;
  keyFormat?: string | undefined;
};

/** @internal */
export const APIKeyAsBasicOptions$outboundSchema: z.ZodType<
  APIKeyAsBasicOptions$Outbound,
  z.ZodTypeDef,
  APIKeyAsBasicOptions
> = z.object({
  fieldUsed: FieldUsed$outboundSchema.optional(),
  keyFormat: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace APIKeyAsBasicOptions$ {
  /** @deprecated use `APIKeyAsBasicOptions$inboundSchema` instead. */
  export const inboundSchema = APIKeyAsBasicOptions$inboundSchema;
  /** @deprecated use `APIKeyAsBasicOptions$outboundSchema` instead. */
  export const outboundSchema = APIKeyAsBasicOptions$outboundSchema;
  /** @deprecated use `APIKeyAsBasicOptions$Outbound` instead. */
  export type Outbound = APIKeyAsBasicOptions$Outbound;
}

export function apiKeyAsBasicOptionsToJSON(
  apiKeyAsBasicOptions: APIKeyAsBasicOptions,
): string {
  return JSON.stringify(
    APIKeyAsBasicOptions$outboundSchema.parse(apiKeyAsBasicOptions),
  );
}

export function apiKeyAsBasicOptionsFromJSON(
  jsonString: string,
): SafeParseResult<APIKeyAsBasicOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => APIKeyAsBasicOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'APIKeyAsBasicOptions' from JSON`,
  );
}

/** @internal */
export const BasicAuthOptions$inboundSchema: z.ZodType<
  BasicAuthOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  apiKeyAsBasic: z.boolean().optional(),
  apiKeyAsBasicOpts: z.lazy(() => APIKeyAsBasicOptions$inboundSchema)
    .optional(),
  docsURL: z.string().optional(),
});

/** @internal */
export type BasicAuthOptions$Outbound = {
  apiKeyAsBasic?: boolean | undefined;
  apiKeyAsBasicOpts?: APIKeyAsBasicOptions$Outbound | undefined;
  docsURL?: string | undefined;
};

/** @internal */
export const BasicAuthOptions$outboundSchema: z.ZodType<
  BasicAuthOptions$Outbound,
  z.ZodTypeDef,
  BasicAuthOptions
> = z.object({
  apiKeyAsBasic: z.boolean().optional(),
  apiKeyAsBasicOpts: z.lazy(() => APIKeyAsBasicOptions$outboundSchema)
    .optional(),
  docsURL: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BasicAuthOptions$ {
  /** @deprecated use `BasicAuthOptions$inboundSchema` instead. */
  export const inboundSchema = BasicAuthOptions$inboundSchema;
  /** @deprecated use `BasicAuthOptions$outboundSchema` instead. */
  export const outboundSchema = BasicAuthOptions$outboundSchema;
  /** @deprecated use `BasicAuthOptions$Outbound` instead. */
  export type Outbound = BasicAuthOptions$Outbound;
}

export function basicAuthOptionsToJSON(
  basicAuthOptions: BasicAuthOptions,
): string {
  return JSON.stringify(
    BasicAuthOptions$outboundSchema.parse(basicAuthOptions),
  );
}

export function basicAuthOptionsFromJSON(
  jsonString: string,
): SafeParseResult<BasicAuthOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BasicAuthOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BasicAuthOptions' from JSON`,
  );
}

/** @internal */
export const BulkWriteSupport$inboundSchema: z.ZodType<
  BulkWriteSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  insert: z.boolean(),
  update: z.boolean(),
  upsert: z.boolean(),
  delete: z.boolean(),
});

/** @internal */
export type BulkWriteSupport$Outbound = {
  insert: boolean;
  update: boolean;
  upsert: boolean;
  delete: boolean;
};

/** @internal */
export const BulkWriteSupport$outboundSchema: z.ZodType<
  BulkWriteSupport$Outbound,
  z.ZodTypeDef,
  BulkWriteSupport
> = z.object({
  insert: z.boolean(),
  update: z.boolean(),
  upsert: z.boolean(),
  delete: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkWriteSupport$ {
  /** @deprecated use `BulkWriteSupport$inboundSchema` instead. */
  export const inboundSchema = BulkWriteSupport$inboundSchema;
  /** @deprecated use `BulkWriteSupport$outboundSchema` instead. */
  export const outboundSchema = BulkWriteSupport$outboundSchema;
  /** @deprecated use `BulkWriteSupport$Outbound` instead. */
  export type Outbound = BulkWriteSupport$Outbound;
}

export function bulkWriteSupportToJSON(
  bulkWriteSupport: BulkWriteSupport,
): string {
  return JSON.stringify(
    BulkWriteSupport$outboundSchema.parse(bulkWriteSupport),
  );
}

export function bulkWriteSupportFromJSON(
  jsonString: string,
): SafeParseResult<BulkWriteSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkWriteSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkWriteSupport' from JSON`,
  );
}

/** @internal */
export const SubscribeSupport$inboundSchema: z.ZodType<
  SubscribeSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  create: z.boolean().optional(),
  update: z.boolean().optional(),
  delete: z.boolean().optional(),
  passThrough: z.boolean().optional(),
});

/** @internal */
export type SubscribeSupport$Outbound = {
  create?: boolean | undefined;
  update?: boolean | undefined;
  delete?: boolean | undefined;
  passThrough?: boolean | undefined;
};

/** @internal */
export const SubscribeSupport$outboundSchema: z.ZodType<
  SubscribeSupport$Outbound,
  z.ZodTypeDef,
  SubscribeSupport
> = z.object({
  create: z.boolean().optional(),
  update: z.boolean().optional(),
  delete: z.boolean().optional(),
  passThrough: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribeSupport$ {
  /** @deprecated use `SubscribeSupport$inboundSchema` instead. */
  export const inboundSchema = SubscribeSupport$inboundSchema;
  /** @deprecated use `SubscribeSupport$outboundSchema` instead. */
  export const outboundSchema = SubscribeSupport$outboundSchema;
  /** @deprecated use `SubscribeSupport$Outbound` instead. */
  export type Outbound = SubscribeSupport$Outbound;
}

export function subscribeSupportToJSON(
  subscribeSupport: SubscribeSupport,
): string {
  return JSON.stringify(
    SubscribeSupport$outboundSchema.parse(subscribeSupport),
  );
}

export function subscribeSupportFromJSON(
  jsonString: string,
): SafeParseResult<SubscribeSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribeSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribeSupport' from JSON`,
  );
}

/** @internal */
export const Support$inboundSchema: z.ZodType<Support, z.ZodTypeDef, unknown> =
  z.object({
    bulkWrite: z.lazy(() => BulkWriteSupport$inboundSchema),
    proxy: z.boolean(),
    read: z.boolean(),
    subscribe: z.boolean(),
    write: z.boolean(),
    subscribeSupport: z.lazy(() => SubscribeSupport$inboundSchema).optional(),
  });

/** @internal */
export type Support$Outbound = {
  bulkWrite: BulkWriteSupport$Outbound;
  proxy: boolean;
  read: boolean;
  subscribe: boolean;
  write: boolean;
  subscribeSupport?: SubscribeSupport$Outbound | undefined;
};

/** @internal */
export const Support$outboundSchema: z.ZodType<
  Support$Outbound,
  z.ZodTypeDef,
  Support
> = z.object({
  bulkWrite: z.lazy(() => BulkWriteSupport$outboundSchema),
  proxy: z.boolean(),
  read: z.boolean(),
  subscribe: z.boolean(),
  write: z.boolean(),
  subscribeSupport: z.lazy(() => SubscribeSupport$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Support$ {
  /** @deprecated use `Support$inboundSchema` instead. */
  export const inboundSchema = Support$inboundSchema;
  /** @deprecated use `Support$outboundSchema` instead. */
  export const outboundSchema = Support$outboundSchema;
  /** @deprecated use `Support$Outbound` instead. */
  export type Outbound = Support$Outbound;
}

export function supportToJSON(support: Support): string {
  return JSON.stringify(Support$outboundSchema.parse(support));
}

export function supportFromJSON(
  jsonString: string,
): SafeParseResult<Support, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Support$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Support' from JSON`,
  );
}

/** @internal */
export const MediaTypeRegular$inboundSchema: z.ZodType<
  MediaTypeRegular,
  z.ZodTypeDef,
  unknown
> = z.object({
  iconURL: z.string().optional(),
  logoURL: z.string().optional(),
});

/** @internal */
export type MediaTypeRegular$Outbound = {
  iconURL?: string | undefined;
  logoURL?: string | undefined;
};

/** @internal */
export const MediaTypeRegular$outboundSchema: z.ZodType<
  MediaTypeRegular$Outbound,
  z.ZodTypeDef,
  MediaTypeRegular
> = z.object({
  iconURL: z.string().optional(),
  logoURL: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaTypeRegular$ {
  /** @deprecated use `MediaTypeRegular$inboundSchema` instead. */
  export const inboundSchema = MediaTypeRegular$inboundSchema;
  /** @deprecated use `MediaTypeRegular$outboundSchema` instead. */
  export const outboundSchema = MediaTypeRegular$outboundSchema;
  /** @deprecated use `MediaTypeRegular$Outbound` instead. */
  export type Outbound = MediaTypeRegular$Outbound;
}

export function mediaTypeRegularToJSON(
  mediaTypeRegular: MediaTypeRegular,
): string {
  return JSON.stringify(
    MediaTypeRegular$outboundSchema.parse(mediaTypeRegular),
  );
}

export function mediaTypeRegularFromJSON(
  jsonString: string,
): SafeParseResult<MediaTypeRegular, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaTypeRegular$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaTypeRegular' from JSON`,
  );
}

/** @internal */
export const MediaTypeDarkMode$inboundSchema: z.ZodType<
  MediaTypeDarkMode,
  z.ZodTypeDef,
  unknown
> = z.object({
  iconURL: z.string().optional(),
  logoURL: z.string().optional(),
});

/** @internal */
export type MediaTypeDarkMode$Outbound = {
  iconURL?: string | undefined;
  logoURL?: string | undefined;
};

/** @internal */
export const MediaTypeDarkMode$outboundSchema: z.ZodType<
  MediaTypeDarkMode$Outbound,
  z.ZodTypeDef,
  MediaTypeDarkMode
> = z.object({
  iconURL: z.string().optional(),
  logoURL: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaTypeDarkMode$ {
  /** @deprecated use `MediaTypeDarkMode$inboundSchema` instead. */
  export const inboundSchema = MediaTypeDarkMode$inboundSchema;
  /** @deprecated use `MediaTypeDarkMode$outboundSchema` instead. */
  export const outboundSchema = MediaTypeDarkMode$outboundSchema;
  /** @deprecated use `MediaTypeDarkMode$Outbound` instead. */
  export type Outbound = MediaTypeDarkMode$Outbound;
}

export function mediaTypeDarkModeToJSON(
  mediaTypeDarkMode: MediaTypeDarkMode,
): string {
  return JSON.stringify(
    MediaTypeDarkMode$outboundSchema.parse(mediaTypeDarkMode),
  );
}

export function mediaTypeDarkModeFromJSON(
  jsonString: string,
): SafeParseResult<MediaTypeDarkMode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaTypeDarkMode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaTypeDarkMode' from JSON`,
  );
}

/** @internal */
export const Media$inboundSchema: z.ZodType<Media, z.ZodTypeDef, unknown> = z
  .object({
    regular: z.lazy(() => MediaTypeRegular$inboundSchema).optional(),
    darkMode: z.lazy(() => MediaTypeDarkMode$inboundSchema).optional(),
  });

/** @internal */
export type Media$Outbound = {
  regular?: MediaTypeRegular$Outbound | undefined;
  darkMode?: MediaTypeDarkMode$Outbound | undefined;
};

/** @internal */
export const Media$outboundSchema: z.ZodType<
  Media$Outbound,
  z.ZodTypeDef,
  Media
> = z.object({
  regular: z.lazy(() => MediaTypeRegular$outboundSchema).optional(),
  darkMode: z.lazy(() => MediaTypeDarkMode$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Media$ {
  /** @deprecated use `Media$inboundSchema` instead. */
  export const inboundSchema = Media$inboundSchema;
  /** @deprecated use `Media$outboundSchema` instead. */
  export const outboundSchema = Media$outboundSchema;
  /** @deprecated use `Media$Outbound` instead. */
  export type Outbound = Media$Outbound;
}

export function mediaToJSON(media: Media): string {
  return JSON.stringify(Media$outboundSchema.parse(media));
}

export function mediaFromJSON(
  jsonString: string,
): SafeParseResult<Media, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Media$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Media' from JSON`,
  );
}

/** @internal */
export const SubscriptionScope$inboundSchema: z.ZodNativeEnum<
  typeof SubscriptionScope
> = z.nativeEnum(SubscriptionScope);

/** @internal */
export const SubscriptionScope$outboundSchema: z.ZodNativeEnum<
  typeof SubscriptionScope
> = SubscriptionScope$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionScope$ {
  /** @deprecated use `SubscriptionScope$inboundSchema` instead. */
  export const inboundSchema = SubscriptionScope$inboundSchema;
  /** @deprecated use `SubscriptionScope$outboundSchema` instead. */
  export const outboundSchema = SubscriptionScope$outboundSchema;
}

/** @internal */
export const TargetURLScope$inboundSchema: z.ZodNativeEnum<
  typeof TargetURLScope
> = z.nativeEnum(TargetURLScope);

/** @internal */
export const TargetURLScope$outboundSchema: z.ZodNativeEnum<
  typeof TargetURLScope
> = TargetURLScope$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TargetURLScope$ {
  /** @deprecated use `TargetURLScope$inboundSchema` instead. */
  export const inboundSchema = TargetURLScope$inboundSchema;
  /** @deprecated use `TargetURLScope$outboundSchema` instead. */
  export const outboundSchema = TargetURLScope$outboundSchema;
}

/** @internal */
export const RegistrationTiming$inboundSchema: z.ZodNativeEnum<
  typeof RegistrationTiming
> = z.nativeEnum(RegistrationTiming);

/** @internal */
export const RegistrationTiming$outboundSchema: z.ZodNativeEnum<
  typeof RegistrationTiming
> = RegistrationTiming$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RegistrationTiming$ {
  /** @deprecated use `RegistrationTiming$inboundSchema` instead. */
  export const inboundSchema = RegistrationTiming$inboundSchema;
  /** @deprecated use `RegistrationTiming$outboundSchema` instead. */
  export const outboundSchema = RegistrationTiming$outboundSchema;
}

/** @internal */
export const SubscribeOptions$inboundSchema: z.ZodType<
  SubscribeOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  subscriptionScope: SubscriptionScope$inboundSchema,
  targetURLScope: TargetURLScope$inboundSchema,
  registrationTiming: RegistrationTiming$inboundSchema,
});

/** @internal */
export type SubscribeOptions$Outbound = {
  subscriptionScope: string;
  targetURLScope: string;
  registrationTiming: string;
};

/** @internal */
export const SubscribeOptions$outboundSchema: z.ZodType<
  SubscribeOptions$Outbound,
  z.ZodTypeDef,
  SubscribeOptions
> = z.object({
  subscriptionScope: SubscriptionScope$outboundSchema,
  targetURLScope: TargetURLScope$outboundSchema,
  registrationTiming: RegistrationTiming$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribeOptions$ {
  /** @deprecated use `SubscribeOptions$inboundSchema` instead. */
  export const inboundSchema = SubscribeOptions$inboundSchema;
  /** @deprecated use `SubscribeOptions$outboundSchema` instead. */
  export const outboundSchema = SubscribeOptions$outboundSchema;
  /** @deprecated use `SubscribeOptions$Outbound` instead. */
  export type Outbound = SubscribeOptions$Outbound;
}

export function subscribeOptionsToJSON(
  subscribeOptions: SubscribeOptions,
): string {
  return JSON.stringify(
    SubscribeOptions$outboundSchema.parse(subscribeOptions),
  );
}

export function subscribeOptionsFromJSON(
  jsonString: string,
): SafeParseResult<SubscribeOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribeOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribeOptions' from JSON`,
  );
}

/** @internal */
export const ListProvidersBulkWriteSupport$inboundSchema: z.ZodType<
  ListProvidersBulkWriteSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  insert: z.boolean(),
  update: z.boolean(),
  upsert: z.boolean(),
  delete: z.boolean(),
});

/** @internal */
export type ListProvidersBulkWriteSupport$Outbound = {
  insert: boolean;
  update: boolean;
  upsert: boolean;
  delete: boolean;
};

/** @internal */
export const ListProvidersBulkWriteSupport$outboundSchema: z.ZodType<
  ListProvidersBulkWriteSupport$Outbound,
  z.ZodTypeDef,
  ListProvidersBulkWriteSupport
> = z.object({
  insert: z.boolean(),
  update: z.boolean(),
  upsert: z.boolean(),
  delete: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersBulkWriteSupport$ {
  /** @deprecated use `ListProvidersBulkWriteSupport$inboundSchema` instead. */
  export const inboundSchema = ListProvidersBulkWriteSupport$inboundSchema;
  /** @deprecated use `ListProvidersBulkWriteSupport$outboundSchema` instead. */
  export const outboundSchema = ListProvidersBulkWriteSupport$outboundSchema;
  /** @deprecated use `ListProvidersBulkWriteSupport$Outbound` instead. */
  export type Outbound = ListProvidersBulkWriteSupport$Outbound;
}

export function listProvidersBulkWriteSupportToJSON(
  listProvidersBulkWriteSupport: ListProvidersBulkWriteSupport,
): string {
  return JSON.stringify(
    ListProvidersBulkWriteSupport$outboundSchema.parse(
      listProvidersBulkWriteSupport,
    ),
  );
}

export function listProvidersBulkWriteSupportFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersBulkWriteSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersBulkWriteSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersBulkWriteSupport' from JSON`,
  );
}

/** @internal */
export const ListProvidersSubscribeSupport$inboundSchema: z.ZodType<
  ListProvidersSubscribeSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  create: z.boolean().optional(),
  update: z.boolean().optional(),
  delete: z.boolean().optional(),
  passThrough: z.boolean().optional(),
});

/** @internal */
export type ListProvidersSubscribeSupport$Outbound = {
  create?: boolean | undefined;
  update?: boolean | undefined;
  delete?: boolean | undefined;
  passThrough?: boolean | undefined;
};

/** @internal */
export const ListProvidersSubscribeSupport$outboundSchema: z.ZodType<
  ListProvidersSubscribeSupport$Outbound,
  z.ZodTypeDef,
  ListProvidersSubscribeSupport
> = z.object({
  create: z.boolean().optional(),
  update: z.boolean().optional(),
  delete: z.boolean().optional(),
  passThrough: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersSubscribeSupport$ {
  /** @deprecated use `ListProvidersSubscribeSupport$inboundSchema` instead. */
  export const inboundSchema = ListProvidersSubscribeSupport$inboundSchema;
  /** @deprecated use `ListProvidersSubscribeSupport$outboundSchema` instead. */
  export const outboundSchema = ListProvidersSubscribeSupport$outboundSchema;
  /** @deprecated use `ListProvidersSubscribeSupport$Outbound` instead. */
  export type Outbound = ListProvidersSubscribeSupport$Outbound;
}

export function listProvidersSubscribeSupportToJSON(
  listProvidersSubscribeSupport: ListProvidersSubscribeSupport,
): string {
  return JSON.stringify(
    ListProvidersSubscribeSupport$outboundSchema.parse(
      listProvidersSubscribeSupport,
    ),
  );
}

export function listProvidersSubscribeSupportFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersSubscribeSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersSubscribeSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersSubscribeSupport' from JSON`,
  );
}

/** @internal */
export const ListProvidersSupport$inboundSchema: z.ZodType<
  ListProvidersSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  bulkWrite: z.lazy(() => ListProvidersBulkWriteSupport$inboundSchema),
  proxy: z.boolean(),
  read: z.boolean(),
  subscribe: z.boolean(),
  write: z.boolean(),
  subscribeSupport: z.lazy(() => ListProvidersSubscribeSupport$inboundSchema)
    .optional(),
});

/** @internal */
export type ListProvidersSupport$Outbound = {
  bulkWrite: ListProvidersBulkWriteSupport$Outbound;
  proxy: boolean;
  read: boolean;
  subscribe: boolean;
  write: boolean;
  subscribeSupport?: ListProvidersSubscribeSupport$Outbound | undefined;
};

/** @internal */
export const ListProvidersSupport$outboundSchema: z.ZodType<
  ListProvidersSupport$Outbound,
  z.ZodTypeDef,
  ListProvidersSupport
> = z.object({
  bulkWrite: z.lazy(() => ListProvidersBulkWriteSupport$outboundSchema),
  proxy: z.boolean(),
  read: z.boolean(),
  subscribe: z.boolean(),
  write: z.boolean(),
  subscribeSupport: z.lazy(() => ListProvidersSubscribeSupport$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersSupport$ {
  /** @deprecated use `ListProvidersSupport$inboundSchema` instead. */
  export const inboundSchema = ListProvidersSupport$inboundSchema;
  /** @deprecated use `ListProvidersSupport$outboundSchema` instead. */
  export const outboundSchema = ListProvidersSupport$outboundSchema;
  /** @deprecated use `ListProvidersSupport$Outbound` instead. */
  export type Outbound = ListProvidersSupport$Outbound;
}

export function listProvidersSupportToJSON(
  listProvidersSupport: ListProvidersSupport,
): string {
  return JSON.stringify(
    ListProvidersSupport$outboundSchema.parse(listProvidersSupport),
  );
}

export function listProvidersSupportFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersSupport' from JSON`,
  );
}

/** @internal */
export const ModuleInfo$inboundSchema: z.ZodType<
  ModuleInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  displayName: z.string(),
  baseURL: z.string(),
  support: z.lazy(() => ListProvidersSupport$inboundSchema),
});

/** @internal */
export type ModuleInfo$Outbound = {
  displayName: string;
  baseURL: string;
  support: ListProvidersSupport$Outbound;
};

/** @internal */
export const ModuleInfo$outboundSchema: z.ZodType<
  ModuleInfo$Outbound,
  z.ZodTypeDef,
  ModuleInfo
> = z.object({
  displayName: z.string(),
  baseURL: z.string(),
  support: z.lazy(() => ListProvidersSupport$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModuleInfo$ {
  /** @deprecated use `ModuleInfo$inboundSchema` instead. */
  export const inboundSchema = ModuleInfo$inboundSchema;
  /** @deprecated use `ModuleInfo$outboundSchema` instead. */
  export const outboundSchema = ModuleInfo$outboundSchema;
  /** @deprecated use `ModuleInfo$Outbound` instead. */
  export type Outbound = ModuleInfo$Outbound;
}

export function moduleInfoToJSON(moduleInfo: ModuleInfo): string {
  return JSON.stringify(ModuleInfo$outboundSchema.parse(moduleInfo));
}

export function moduleInfoFromJSON(
  jsonString: string,
): SafeParseResult<ModuleInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModuleInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModuleInfo' from JSON`,
  );
}

/** @internal */
export const ProviderInfo$inboundSchema: z.ZodType<
  ProviderInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  authType: AuthType$inboundSchema,
  baseURL: z.string(),
  oauth2Opts: z.lazy(() => OAuth2Options$inboundSchema).optional(),
  apiKeyOpts: z.lazy(() => APIKeyOptions$inboundSchema).optional(),
  basicOpts: z.lazy(() => BasicAuthOptions$inboundSchema).optional(),
  support: z.lazy(() => Support$inboundSchema),
  providerOpts: z.record(z.string()),
  displayName: z.string().optional(),
  postAuthInfoNeeded: z.boolean().optional(),
  media: z.lazy(() => Media$inboundSchema).optional(),
  labels: z.record(z.string()).optional(),
  subscribeOpts: z.lazy(() => SubscribeOptions$inboundSchema).optional(),
  modules: z.record(z.lazy(() => ModuleInfo$inboundSchema)).optional(),
});

/** @internal */
export type ProviderInfo$Outbound = {
  name: string;
  authType: string;
  baseURL: string;
  oauth2Opts?: OAuth2Options$Outbound | undefined;
  apiKeyOpts?: APIKeyOptions$Outbound | undefined;
  basicOpts?: BasicAuthOptions$Outbound | undefined;
  support: Support$Outbound;
  providerOpts: { [k: string]: string };
  displayName?: string | undefined;
  postAuthInfoNeeded?: boolean | undefined;
  media?: Media$Outbound | undefined;
  labels?: { [k: string]: string } | undefined;
  subscribeOpts?: SubscribeOptions$Outbound | undefined;
  modules?: { [k: string]: ModuleInfo$Outbound } | undefined;
};

/** @internal */
export const ProviderInfo$outboundSchema: z.ZodType<
  ProviderInfo$Outbound,
  z.ZodTypeDef,
  ProviderInfo
> = z.object({
  name: z.string(),
  authType: AuthType$outboundSchema,
  baseURL: z.string(),
  oauth2Opts: z.lazy(() => OAuth2Options$outboundSchema).optional(),
  apiKeyOpts: z.lazy(() => APIKeyOptions$outboundSchema).optional(),
  basicOpts: z.lazy(() => BasicAuthOptions$outboundSchema).optional(),
  support: z.lazy(() => Support$outboundSchema),
  providerOpts: z.record(z.string()),
  displayName: z.string().optional(),
  postAuthInfoNeeded: z.boolean().optional(),
  media: z.lazy(() => Media$outboundSchema).optional(),
  labels: z.record(z.string()).optional(),
  subscribeOpts: z.lazy(() => SubscribeOptions$outboundSchema).optional(),
  modules: z.record(z.lazy(() => ModuleInfo$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProviderInfo$ {
  /** @deprecated use `ProviderInfo$inboundSchema` instead. */
  export const inboundSchema = ProviderInfo$inboundSchema;
  /** @deprecated use `ProviderInfo$outboundSchema` instead. */
  export const outboundSchema = ProviderInfo$outboundSchema;
  /** @deprecated use `ProviderInfo$Outbound` instead. */
  export type Outbound = ProviderInfo$Outbound;
}

export function providerInfoToJSON(providerInfo: ProviderInfo): string {
  return JSON.stringify(ProviderInfo$outboundSchema.parse(providerInfo));
}

export function providerInfoFromJSON(
  jsonString: string,
): SafeParseResult<ProviderInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProviderInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProviderInfo' from JSON`,
  );
}

/** @internal */
export const ListProvidersResponse$inboundSchema: z.ZodType<
  ListProvidersResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListProvidersAPIProblem$inboundSchema),
  z.record(z.lazy(() => ProviderInfo$inboundSchema)),
]);

/** @internal */
export type ListProvidersResponse$Outbound =
  | ListProvidersAPIProblem$Outbound
  | { [k: string]: ProviderInfo$Outbound };

/** @internal */
export const ListProvidersResponse$outboundSchema: z.ZodType<
  ListProvidersResponse$Outbound,
  z.ZodTypeDef,
  ListProvidersResponse
> = z.union([
  z.lazy(() => ListProvidersAPIProblem$outboundSchema),
  z.record(z.lazy(() => ProviderInfo$outboundSchema)),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersResponse$ {
  /** @deprecated use `ListProvidersResponse$inboundSchema` instead. */
  export const inboundSchema = ListProvidersResponse$inboundSchema;
  /** @deprecated use `ListProvidersResponse$outboundSchema` instead. */
  export const outboundSchema = ListProvidersResponse$outboundSchema;
  /** @deprecated use `ListProvidersResponse$Outbound` instead. */
  export type Outbound = ListProvidersResponse$Outbound;
}

export function listProvidersResponseToJSON(
  listProvidersResponse: ListProvidersResponse,
): string {
  return JSON.stringify(
    ListProvidersResponse$outboundSchema.parse(listProvidersResponse),
  );
}

export function listProvidersResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersResponse' from JSON`,
  );
}
