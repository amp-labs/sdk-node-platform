/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * A Problem Details object (RFC 9457).
 *
 * @remarks
 *
 * Additional properties specific to the problem type may be present.
 */
export type ListProvidersAPIProblem = {
  /**
   * An absolute URI that identifies the problem type
   */
  type?: string | undefined;
  /**
   * An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
   */
  href?: string | undefined;
  /**
   * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
   */
  title?: string | undefined;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   */
  status?: number | undefined;
  /**
   * A human-readable explanation specific to this occurrence of the problem
   */
  detail?: string | undefined;
  /**
   * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   */
  instance?: string | undefined;
  /**
   * The subsystem that generated the problem
   */
  subsystem?: string | undefined;
  /**
   * The time the problem occurred, formatted as RFC-3339
   */
  time?: Date | undefined;
  /**
   * A unique identifier for the request, useful for debugging
   */
  requestId?: string | undefined;
  /**
   * A list of problems that caused this problem. This can be used to represent multiple
   *
   * @remarks
   * root causes. There is no guaranteed ordering of the causes.
   */
  causes?: Array<string> | undefined;
  /**
   * A brief description of how to resolve the problem
   */
  remedy?: string | undefined;
  /**
   * An email address to contact for support
   */
  supportEmail?: string | undefined;
  /**
   * A phone number to contact for support
   */
  supportPhone?: string | undefined;
  /**
   * A URL to contact for support
   */
  supportUrl?: string | undefined;
  /**
   * Whether the request can be retried
   */
  retryable?: boolean | undefined;
  /**
   * A timestamp after which the request can be retried, formatted as RFC-3339
   */
  retryAfter?: Date | undefined;
  /**
   * Additional context for the problem
   */
  context?: { [k: string]: any } | undefined;
};

/**
 * The type of authentication required by the provider.
 */
export const AuthType = {
  Oauth2: "oauth2",
  ApiKey: "apiKey",
  Basic: "basic",
  Jwt: "jwt",
  None: "none",
} as const;
/**
 * The type of authentication required by the provider.
 */
export type AuthType = ClosedEnum<typeof AuthType>;

export const GrantType = {
  AuthorizationCode: "authorizationCode",
  AuthorizationCodePKCE: "authorizationCodePKCE",
  ClientCredentials: "clientCredentials",
  Password: "password",
} as const;
export type GrantType = ClosedEnum<typeof GrantType>;

export type OtherFields = {
  /**
   * The internal name of the field
   */
  name: string;
  /**
   * The human-readable name of the field
   */
  displayName: string;
  /**
   * The path to the field in the token response (accepts dot notation for nested fields)
   */
  path: string;
  /**
   * A regex expression to capture the value that we need from the path. There must be only one capture group named 'result' in the expression. If not provided, will cause an error.
   */
  capture?: string | undefined;
};

/**
 * Fields to be used to extract token metadata from the token response.
 */
export type TokenMetadataFields = {
  workspaceRefField?: string | undefined;
  consumerRefField?: string | undefined;
  scopesField?: string | undefined;
  /**
   * Additional fields to extract and transform from the token response
   */
  otherFields?: Array<OtherFields> | undefined;
};

/**
 * Configuration for OAuth2.0. Must be provided if authType is oauth2.
 */
export type OAuth2Options = {
  grantType: GrantType;
  /**
   * The authorization URL.
   */
  authURL?: string | undefined;
  /**
   * The token URL.
   */
  tokenURL: string;
  /**
   * Whether scopes are required to be known ahead of the OAuth flow.
   */
  explicitScopesRequired: boolean;
  /**
   * Whether the workspace is required to be known ahead of the OAuth flow.
   */
  explicitWorkspaceRequired: boolean;
  /**
   * A list of URLs that represent the audience for the token, which is needed for some client credential grant flows.
   */
  audience?: Array<string> | undefined;
  /**
   * Fields to be used to extract token metadata from the token response.
   */
  tokenMetadataFields: TokenMetadataFields;
  /**
   * URL with more information about where to retrieve Client ID and Client Secret, etc.
   */
  docsURL?: string | undefined;
  authURLParams?: { [k: string]: string } | undefined;
};

/**
 * How the API key should be attached to requests.
 */
export const AttachmentType = {
  Query: "query",
  Header: "header",
} as const;
/**
 * How the API key should be attached to requests.
 */
export type AttachmentType = ClosedEnum<typeof AttachmentType>;

/**
 * Configuration for API key in query parameter. Must be provided if type is in-query.
 */
export type APIKeyQueryOptions = {
  /**
   * The name of the query parameter to be used for the API key.
   */
  name: string;
};

/**
 * Configuration for API key in header. Must be provided if type is in-header.
 */
export type APIKeyHeaderOptions = {
  /**
   * The name of the header to be used for the API key.
   */
  name: string;
  /**
   * The prefix to be added to the API key value when it is sent in the header.
   */
  valuePrefix?: string | undefined;
};

/**
 * Configuration for API key. Must be provided if authType is apiKey.
 */
export type APIKeyOptions = {
  /**
   * How the API key should be attached to requests.
   */
  attachmentType: AttachmentType;
  /**
   * Configuration for API key in query parameter. Must be provided if type is in-query.
   */
  query?: APIKeyQueryOptions | undefined;
  /**
   * Configuration for API key in header. Must be provided if type is in-header.
   */
  header?: APIKeyHeaderOptions | undefined;
  /**
   * URL with more information about how to get or use an API key.
   */
  docsURL?: string | undefined;
};

/**
 * whether the API key should be used as the username or password.
 */
export const FieldUsed = {
  Username: "username",
  Password: "password",
} as const;
/**
 * whether the API key should be used as the username or password.
 */
export type FieldUsed = ClosedEnum<typeof FieldUsed>;

/**
 * when this object is present, it means that this provider uses Basic Auth to actually collect an API key
 */
export type APIKeyAsBasicOptions = {
  /**
   * whether the API key should be used as the username or password.
   */
  fieldUsed?: FieldUsed | undefined;
  /**
   * How to transform the API key in to a basic auth user:pass string. The %s is replaced with the API key value.
   */
  keyFormat?: string | undefined;
};

/**
 * Configuration for Basic Auth. Optional.
 */
export type BasicAuthOptions = {
  /**
   * If true, the provider uses an API key which then gets encoded as a basic auth user:pass string.
   */
  apiKeyAsBasic?: boolean | undefined;
  /**
   * when this object is present, it means that this provider uses Basic Auth to actually collect an API key
   */
  apiKeyAsBasicOpts?: APIKeyAsBasicOptions | undefined;
  /**
   * URL with more information about how to get or use an API key.
   */
  docsURL?: string | undefined;
};

export type BulkWriteSupport = {
  insert: boolean;
  update: boolean;
  upsert: boolean;
  delete: boolean;
};

export type SubscribeSupport = {
  create?: boolean | undefined;
  update?: boolean | undefined;
  delete?: boolean | undefined;
  passThrough?: boolean | undefined;
};

/**
 * The supported features for the provider.
 */
export type Support = {
  bulkWrite: BulkWriteSupport;
  proxy: boolean;
  read: boolean;
  subscribe: boolean;
  write: boolean;
  subscribeSupport?: SubscribeSupport | undefined;
};

/**
 * A URL to check the health of a provider's credentials. It's used to see if the credentials are valid and if the provider is reachable.
 */
export type AuthHealthCheck = {
  /**
   * a no-op URL to check the health of the credentials. The URL MUST not mutate any state. If the provider doesn't have such an endpoint, then don't provide credentialsHealthCheck.
   */
  url: string;
  /**
   * The HTTP method to use for the health check. If not set, defaults to GET.
   */
  method?: string | undefined;
  /**
   * The HTTP status codes that indicate a successful health check. If not set, defaults to 200 and 204.
   */
  successStatusCodes?: Array<number> | undefined;
};

/**
 * Media for light/regular mode.
 */
export type MediaTypeRegular = {
  /**
   * URL to the icon for the provider.
   */
  iconURL?: string | undefined;
  /**
   * URL to the logo for the provider.
   */
  logoURL?: string | undefined;
};

/**
 * Media to be used in dark mode.
 */
export type MediaTypeDarkMode = {
  /**
   * URL to the icon for the provider that is to be used in dark mode.
   */
  iconURL?: string | undefined;
  /**
   * URL to the logo for the provider that is to be used in dark mode.
   */
  logoURL?: string | undefined;
};

export type Media = {
  /**
   * Media for light/regular mode.
   */
  regular?: MediaTypeRegular | undefined;
  /**
   * Media to be used in dark mode.
   */
  darkMode?: MediaTypeDarkMode | undefined;
};

/**
 * The scope of the subscription.
 */
export const SubscriptionScope = {
  Integration: "integration",
  Installation: "installation",
} as const;
/**
 * The scope of the subscription.
 */
export type SubscriptionScope = ClosedEnum<typeof SubscriptionScope>;

/**
 * The scope of the target URL.
 */
export const TargetURLScope = {
  Integration: "integration",
  Installation: "installation",
} as const;
/**
 * The scope of the target URL.
 */
export type TargetURLScope = ClosedEnum<typeof TargetURLScope>;

/**
 * The timing of the registration.
 */
export const RegistrationTiming = {
  ProviderApp: "providerApp",
  Integration: "integration",
  Installation: "installation",
} as const;
/**
 * The timing of the registration.
 */
export type RegistrationTiming = ClosedEnum<typeof RegistrationTiming>;

export type SubscribeOptions = {
  /**
   * The scope of the subscription.
   */
  subscriptionScope: SubscriptionScope;
  /**
   * The scope of the target URL.
   */
  targetURLScope: TargetURLScope;
  /**
   * The timing of the registration.
   */
  registrationTiming: RegistrationTiming;
};

export type ListProvidersBulkWriteSupport = {
  insert: boolean;
  update: boolean;
  upsert: boolean;
  delete: boolean;
};

export type ListProvidersSubscribeSupport = {
  create?: boolean | undefined;
  update?: boolean | undefined;
  delete?: boolean | undefined;
  passThrough?: boolean | undefined;
};

/**
 * The supported features for the provider.
 */
export type ListProvidersSupport = {
  bulkWrite: ListProvidersBulkWriteSupport;
  proxy: boolean;
  read: boolean;
  subscribe: boolean;
  write: boolean;
  subscribeSupport?: ListProvidersSubscribeSupport | undefined;
};

export type ModuleInfo = {
  displayName: string;
  baseURL: string;
  /**
   * The supported features for the provider.
   */
  support: ListProvidersSupport;
};

/**
 * Dependency for a single module.
 */
export type ModuleDependency = {};

export type MetadataItemAsInput = {
  /**
   * The internal identifier for the metadata field
   */
  name: string;
  /**
   * The human-readable name for the field
   */
  displayName?: string | undefined;
  /**
   * URL with more information about how to locate this value
   */
  docsURL?: string | undefined;
  /**
   * Module-specific dependencies for this metadata item.
   */
  moduleDependencies?: { [k: string]: ModuleDependency } | undefined;
};

/**
 * Dependency for a single module.
 */
export type ListProvidersModuleDependency = {};

export type MetadataItemFetchedPostAuthentication = {
  /**
   * The internal identifier for the metadata field
   */
  name: string;
  /**
   * Module-specific dependencies for this metadata item.
   */
  moduleDependencies?:
    | { [k: string]: ListProvidersModuleDependency }
    | undefined;
};

/**
 * Provider metadata that needs to be given by the user or fetched by the connector post authentication for the connector to work.
 */
export type ProviderMetadata = {
  /**
   * Metadata provided as manual input
   */
  input?: Array<MetadataItemAsInput> | undefined;
  /**
   * Metadata fetched by the connector post authentication
   */
  postAuthentication?: Array<MetadataItemFetchedPostAuthentication> | undefined;
};

export type ProviderInfo = {
  name: string;
  /**
   * The type of authentication required by the provider.
   */
  authType: AuthType;
  /**
   * The base URL for making API requests.
   */
  baseURL: string;
  defaultModule?: any | undefined;
  /**
   * Configuration for OAuth2.0. Must be provided if authType is oauth2.
   */
  oauth2Opts?: OAuth2Options | undefined;
  /**
   * Configuration for API key. Must be provided if authType is apiKey.
   */
  apiKeyOpts?: APIKeyOptions | undefined;
  /**
   * Configuration for Basic Auth. Optional.
   */
  basicOpts?: BasicAuthOptions | undefined;
  /**
   * The supported features for the provider.
   */
  support: Support;
  /**
   * Additional provider-specific metadata.
   */
  providerOpts: { [k: string]: string };
  /**
   * A URL to check the health of a provider's credentials. It's used to see if the credentials are valid and if the provider is reachable.
   */
  authHealthCheck?: AuthHealthCheck | undefined;
  /**
   * The display name of the provider, if omitted, defaults to provider name.
   */
  displayName?: string | undefined;
  /**
   * If true, we require additional information after auth to start making requests.
   */
  postAuthInfoNeeded?: boolean | undefined;
  media?: Media | undefined;
  labels?: { [k: string]: string } | undefined;
  subscribeOpts?: SubscribeOptions | undefined;
  /**
   * The registry of provider modules.
   */
  modules?: { [k: string]: ModuleInfo } | undefined;
  /**
   * Provider metadata that needs to be given by the user or fetched by the connector post authentication for the connector to work.
   */
  metadata?: ProviderMetadata | undefined;
};

export type ListProvidersResponse = ListProvidersAPIProblem | {
  [k: string]: ProviderInfo;
};

/** @internal */
export const ListProvidersAPIProblem$inboundSchema: z.ZodType<
  ListProvidersAPIProblem,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  context: z.record(z.any()).optional(),
});

/** @internal */
export type ListProvidersAPIProblem$Outbound = {
  type: string;
  href?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  subsystem?: string | undefined;
  time?: string | undefined;
  requestId?: string | undefined;
  causes?: Array<string> | undefined;
  remedy?: string | undefined;
  supportEmail?: string | undefined;
  supportPhone?: string | undefined;
  supportUrl?: string | undefined;
  retryable?: boolean | undefined;
  retryAfter?: string | undefined;
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const ListProvidersAPIProblem$outboundSchema: z.ZodType<
  ListProvidersAPIProblem$Outbound,
  z.ZodTypeDef,
  ListProvidersAPIProblem
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.date().transform(v => v.toISOString()).optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.date().transform(v => v.toISOString()).optional(),
  context: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersAPIProblem$ {
  /** @deprecated use `ListProvidersAPIProblem$inboundSchema` instead. */
  export const inboundSchema = ListProvidersAPIProblem$inboundSchema;
  /** @deprecated use `ListProvidersAPIProblem$outboundSchema` instead. */
  export const outboundSchema = ListProvidersAPIProblem$outboundSchema;
  /** @deprecated use `ListProvidersAPIProblem$Outbound` instead. */
  export type Outbound = ListProvidersAPIProblem$Outbound;
}

export function listProvidersAPIProblemToJSON(
  listProvidersAPIProblem: ListProvidersAPIProblem,
): string {
  return JSON.stringify(
    ListProvidersAPIProblem$outboundSchema.parse(listProvidersAPIProblem),
  );
}

export function listProvidersAPIProblemFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersAPIProblem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersAPIProblem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersAPIProblem' from JSON`,
  );
}

/** @internal */
export const AuthType$inboundSchema: z.ZodNativeEnum<typeof AuthType> = z
  .nativeEnum(AuthType);

/** @internal */
export const AuthType$outboundSchema: z.ZodNativeEnum<typeof AuthType> =
  AuthType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthType$ {
  /** @deprecated use `AuthType$inboundSchema` instead. */
  export const inboundSchema = AuthType$inboundSchema;
  /** @deprecated use `AuthType$outboundSchema` instead. */
  export const outboundSchema = AuthType$outboundSchema;
}

/** @internal */
export const GrantType$inboundSchema: z.ZodNativeEnum<typeof GrantType> = z
  .nativeEnum(GrantType);

/** @internal */
export const GrantType$outboundSchema: z.ZodNativeEnum<typeof GrantType> =
  GrantType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GrantType$ {
  /** @deprecated use `GrantType$inboundSchema` instead. */
  export const inboundSchema = GrantType$inboundSchema;
  /** @deprecated use `GrantType$outboundSchema` instead. */
  export const outboundSchema = GrantType$outboundSchema;
}

/** @internal */
export const OtherFields$inboundSchema: z.ZodType<
  OtherFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  displayName: z.string(),
  path: z.string(),
  capture: z.string().optional(),
});

/** @internal */
export type OtherFields$Outbound = {
  name: string;
  displayName: string;
  path: string;
  capture?: string | undefined;
};

/** @internal */
export const OtherFields$outboundSchema: z.ZodType<
  OtherFields$Outbound,
  z.ZodTypeDef,
  OtherFields
> = z.object({
  name: z.string(),
  displayName: z.string(),
  path: z.string(),
  capture: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OtherFields$ {
  /** @deprecated use `OtherFields$inboundSchema` instead. */
  export const inboundSchema = OtherFields$inboundSchema;
  /** @deprecated use `OtherFields$outboundSchema` instead. */
  export const outboundSchema = OtherFields$outboundSchema;
  /** @deprecated use `OtherFields$Outbound` instead. */
  export type Outbound = OtherFields$Outbound;
}

export function otherFieldsToJSON(otherFields: OtherFields): string {
  return JSON.stringify(OtherFields$outboundSchema.parse(otherFields));
}

export function otherFieldsFromJSON(
  jsonString: string,
): SafeParseResult<OtherFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OtherFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OtherFields' from JSON`,
  );
}

/** @internal */
export const TokenMetadataFields$inboundSchema: z.ZodType<
  TokenMetadataFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  workspaceRefField: z.string().optional(),
  consumerRefField: z.string().optional(),
  scopesField: z.string().optional(),
  otherFields: z.array(z.lazy(() => OtherFields$inboundSchema)).optional(),
});

/** @internal */
export type TokenMetadataFields$Outbound = {
  workspaceRefField?: string | undefined;
  consumerRefField?: string | undefined;
  scopesField?: string | undefined;
  otherFields?: Array<OtherFields$Outbound> | undefined;
};

/** @internal */
export const TokenMetadataFields$outboundSchema: z.ZodType<
  TokenMetadataFields$Outbound,
  z.ZodTypeDef,
  TokenMetadataFields
> = z.object({
  workspaceRefField: z.string().optional(),
  consumerRefField: z.string().optional(),
  scopesField: z.string().optional(),
  otherFields: z.array(z.lazy(() => OtherFields$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TokenMetadataFields$ {
  /** @deprecated use `TokenMetadataFields$inboundSchema` instead. */
  export const inboundSchema = TokenMetadataFields$inboundSchema;
  /** @deprecated use `TokenMetadataFields$outboundSchema` instead. */
  export const outboundSchema = TokenMetadataFields$outboundSchema;
  /** @deprecated use `TokenMetadataFields$Outbound` instead. */
  export type Outbound = TokenMetadataFields$Outbound;
}

export function tokenMetadataFieldsToJSON(
  tokenMetadataFields: TokenMetadataFields,
): string {
  return JSON.stringify(
    TokenMetadataFields$outboundSchema.parse(tokenMetadataFields),
  );
}

export function tokenMetadataFieldsFromJSON(
  jsonString: string,
): SafeParseResult<TokenMetadataFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TokenMetadataFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TokenMetadataFields' from JSON`,
  );
}

/** @internal */
export const OAuth2Options$inboundSchema: z.ZodType<
  OAuth2Options,
  z.ZodTypeDef,
  unknown
> = z.object({
  grantType: GrantType$inboundSchema,
  authURL: z.string().optional(),
  tokenURL: z.string(),
  explicitScopesRequired: z.boolean(),
  explicitWorkspaceRequired: z.boolean(),
  audience: z.array(z.string()).optional(),
  tokenMetadataFields: z.lazy(() => TokenMetadataFields$inboundSchema),
  docsURL: z.string().optional(),
  authURLParams: z.record(z.string()).optional(),
});

/** @internal */
export type OAuth2Options$Outbound = {
  grantType: string;
  authURL?: string | undefined;
  tokenURL: string;
  explicitScopesRequired: boolean;
  explicitWorkspaceRequired: boolean;
  audience?: Array<string> | undefined;
  tokenMetadataFields: TokenMetadataFields$Outbound;
  docsURL?: string | undefined;
  authURLParams?: { [k: string]: string } | undefined;
};

/** @internal */
export const OAuth2Options$outboundSchema: z.ZodType<
  OAuth2Options$Outbound,
  z.ZodTypeDef,
  OAuth2Options
> = z.object({
  grantType: GrantType$outboundSchema,
  authURL: z.string().optional(),
  tokenURL: z.string(),
  explicitScopesRequired: z.boolean(),
  explicitWorkspaceRequired: z.boolean(),
  audience: z.array(z.string()).optional(),
  tokenMetadataFields: z.lazy(() => TokenMetadataFields$outboundSchema),
  docsURL: z.string().optional(),
  authURLParams: z.record(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OAuth2Options$ {
  /** @deprecated use `OAuth2Options$inboundSchema` instead. */
  export const inboundSchema = OAuth2Options$inboundSchema;
  /** @deprecated use `OAuth2Options$outboundSchema` instead. */
  export const outboundSchema = OAuth2Options$outboundSchema;
  /** @deprecated use `OAuth2Options$Outbound` instead. */
  export type Outbound = OAuth2Options$Outbound;
}

export function oAuth2OptionsToJSON(oAuth2Options: OAuth2Options): string {
  return JSON.stringify(OAuth2Options$outboundSchema.parse(oAuth2Options));
}

export function oAuth2OptionsFromJSON(
  jsonString: string,
): SafeParseResult<OAuth2Options, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OAuth2Options$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OAuth2Options' from JSON`,
  );
}

/** @internal */
export const AttachmentType$inboundSchema: z.ZodNativeEnum<
  typeof AttachmentType
> = z.nativeEnum(AttachmentType);

/** @internal */
export const AttachmentType$outboundSchema: z.ZodNativeEnum<
  typeof AttachmentType
> = AttachmentType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AttachmentType$ {
  /** @deprecated use `AttachmentType$inboundSchema` instead. */
  export const inboundSchema = AttachmentType$inboundSchema;
  /** @deprecated use `AttachmentType$outboundSchema` instead. */
  export const outboundSchema = AttachmentType$outboundSchema;
}

/** @internal */
export const APIKeyQueryOptions$inboundSchema: z.ZodType<
  APIKeyQueryOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});

/** @internal */
export type APIKeyQueryOptions$Outbound = {
  name: string;
};

/** @internal */
export const APIKeyQueryOptions$outboundSchema: z.ZodType<
  APIKeyQueryOptions$Outbound,
  z.ZodTypeDef,
  APIKeyQueryOptions
> = z.object({
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace APIKeyQueryOptions$ {
  /** @deprecated use `APIKeyQueryOptions$inboundSchema` instead. */
  export const inboundSchema = APIKeyQueryOptions$inboundSchema;
  /** @deprecated use `APIKeyQueryOptions$outboundSchema` instead. */
  export const outboundSchema = APIKeyQueryOptions$outboundSchema;
  /** @deprecated use `APIKeyQueryOptions$Outbound` instead. */
  export type Outbound = APIKeyQueryOptions$Outbound;
}

export function apiKeyQueryOptionsToJSON(
  apiKeyQueryOptions: APIKeyQueryOptions,
): string {
  return JSON.stringify(
    APIKeyQueryOptions$outboundSchema.parse(apiKeyQueryOptions),
  );
}

export function apiKeyQueryOptionsFromJSON(
  jsonString: string,
): SafeParseResult<APIKeyQueryOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => APIKeyQueryOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'APIKeyQueryOptions' from JSON`,
  );
}

/** @internal */
export const APIKeyHeaderOptions$inboundSchema: z.ZodType<
  APIKeyHeaderOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  valuePrefix: z.string().optional(),
});

/** @internal */
export type APIKeyHeaderOptions$Outbound = {
  name: string;
  valuePrefix?: string | undefined;
};

/** @internal */
export const APIKeyHeaderOptions$outboundSchema: z.ZodType<
  APIKeyHeaderOptions$Outbound,
  z.ZodTypeDef,
  APIKeyHeaderOptions
> = z.object({
  name: z.string(),
  valuePrefix: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace APIKeyHeaderOptions$ {
  /** @deprecated use `APIKeyHeaderOptions$inboundSchema` instead. */
  export const inboundSchema = APIKeyHeaderOptions$inboundSchema;
  /** @deprecated use `APIKeyHeaderOptions$outboundSchema` instead. */
  export const outboundSchema = APIKeyHeaderOptions$outboundSchema;
  /** @deprecated use `APIKeyHeaderOptions$Outbound` instead. */
  export type Outbound = APIKeyHeaderOptions$Outbound;
}

export function apiKeyHeaderOptionsToJSON(
  apiKeyHeaderOptions: APIKeyHeaderOptions,
): string {
  return JSON.stringify(
    APIKeyHeaderOptions$outboundSchema.parse(apiKeyHeaderOptions),
  );
}

export function apiKeyHeaderOptionsFromJSON(
  jsonString: string,
): SafeParseResult<APIKeyHeaderOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => APIKeyHeaderOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'APIKeyHeaderOptions' from JSON`,
  );
}

/** @internal */
export const APIKeyOptions$inboundSchema: z.ZodType<
  APIKeyOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  attachmentType: AttachmentType$inboundSchema,
  query: z.lazy(() => APIKeyQueryOptions$inboundSchema).optional(),
  header: z.lazy(() => APIKeyHeaderOptions$inboundSchema).optional(),
  docsURL: z.string().optional(),
});

/** @internal */
export type APIKeyOptions$Outbound = {
  attachmentType: string;
  query?: APIKeyQueryOptions$Outbound | undefined;
  header?: APIKeyHeaderOptions$Outbound | undefined;
  docsURL?: string | undefined;
};

/** @internal */
export const APIKeyOptions$outboundSchema: z.ZodType<
  APIKeyOptions$Outbound,
  z.ZodTypeDef,
  APIKeyOptions
> = z.object({
  attachmentType: AttachmentType$outboundSchema,
  query: z.lazy(() => APIKeyQueryOptions$outboundSchema).optional(),
  header: z.lazy(() => APIKeyHeaderOptions$outboundSchema).optional(),
  docsURL: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace APIKeyOptions$ {
  /** @deprecated use `APIKeyOptions$inboundSchema` instead. */
  export const inboundSchema = APIKeyOptions$inboundSchema;
  /** @deprecated use `APIKeyOptions$outboundSchema` instead. */
  export const outboundSchema = APIKeyOptions$outboundSchema;
  /** @deprecated use `APIKeyOptions$Outbound` instead. */
  export type Outbound = APIKeyOptions$Outbound;
}

export function apiKeyOptionsToJSON(apiKeyOptions: APIKeyOptions): string {
  return JSON.stringify(APIKeyOptions$outboundSchema.parse(apiKeyOptions));
}

export function apiKeyOptionsFromJSON(
  jsonString: string,
): SafeParseResult<APIKeyOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => APIKeyOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'APIKeyOptions' from JSON`,
  );
}

/** @internal */
export const FieldUsed$inboundSchema: z.ZodNativeEnum<typeof FieldUsed> = z
  .nativeEnum(FieldUsed);

/** @internal */
export const FieldUsed$outboundSchema: z.ZodNativeEnum<typeof FieldUsed> =
  FieldUsed$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FieldUsed$ {
  /** @deprecated use `FieldUsed$inboundSchema` instead. */
  export const inboundSchema = FieldUsed$inboundSchema;
  /** @deprecated use `FieldUsed$outboundSchema` instead. */
  export const outboundSchema = FieldUsed$outboundSchema;
}

/** @internal */
export const APIKeyAsBasicOptions$inboundSchema: z.ZodType<
  APIKeyAsBasicOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  fieldUsed: FieldUsed$inboundSchema.optional(),
  keyFormat: z.string().optional(),
});

/** @internal */
export type APIKeyAsBasicOptions$Outbound = {
  fieldUsed?: string | undefined;
  keyFormat?: string | undefined;
};

/** @internal */
export const APIKeyAsBasicOptions$outboundSchema: z.ZodType<
  APIKeyAsBasicOptions$Outbound,
  z.ZodTypeDef,
  APIKeyAsBasicOptions
> = z.object({
  fieldUsed: FieldUsed$outboundSchema.optional(),
  keyFormat: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace APIKeyAsBasicOptions$ {
  /** @deprecated use `APIKeyAsBasicOptions$inboundSchema` instead. */
  export const inboundSchema = APIKeyAsBasicOptions$inboundSchema;
  /** @deprecated use `APIKeyAsBasicOptions$outboundSchema` instead. */
  export const outboundSchema = APIKeyAsBasicOptions$outboundSchema;
  /** @deprecated use `APIKeyAsBasicOptions$Outbound` instead. */
  export type Outbound = APIKeyAsBasicOptions$Outbound;
}

export function apiKeyAsBasicOptionsToJSON(
  apiKeyAsBasicOptions: APIKeyAsBasicOptions,
): string {
  return JSON.stringify(
    APIKeyAsBasicOptions$outboundSchema.parse(apiKeyAsBasicOptions),
  );
}

export function apiKeyAsBasicOptionsFromJSON(
  jsonString: string,
): SafeParseResult<APIKeyAsBasicOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => APIKeyAsBasicOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'APIKeyAsBasicOptions' from JSON`,
  );
}

/** @internal */
export const BasicAuthOptions$inboundSchema: z.ZodType<
  BasicAuthOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  apiKeyAsBasic: z.boolean().optional(),
  apiKeyAsBasicOpts: z.lazy(() => APIKeyAsBasicOptions$inboundSchema)
    .optional(),
  docsURL: z.string().optional(),
});

/** @internal */
export type BasicAuthOptions$Outbound = {
  apiKeyAsBasic?: boolean | undefined;
  apiKeyAsBasicOpts?: APIKeyAsBasicOptions$Outbound | undefined;
  docsURL?: string | undefined;
};

/** @internal */
export const BasicAuthOptions$outboundSchema: z.ZodType<
  BasicAuthOptions$Outbound,
  z.ZodTypeDef,
  BasicAuthOptions
> = z.object({
  apiKeyAsBasic: z.boolean().optional(),
  apiKeyAsBasicOpts: z.lazy(() => APIKeyAsBasicOptions$outboundSchema)
    .optional(),
  docsURL: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BasicAuthOptions$ {
  /** @deprecated use `BasicAuthOptions$inboundSchema` instead. */
  export const inboundSchema = BasicAuthOptions$inboundSchema;
  /** @deprecated use `BasicAuthOptions$outboundSchema` instead. */
  export const outboundSchema = BasicAuthOptions$outboundSchema;
  /** @deprecated use `BasicAuthOptions$Outbound` instead. */
  export type Outbound = BasicAuthOptions$Outbound;
}

export function basicAuthOptionsToJSON(
  basicAuthOptions: BasicAuthOptions,
): string {
  return JSON.stringify(
    BasicAuthOptions$outboundSchema.parse(basicAuthOptions),
  );
}

export function basicAuthOptionsFromJSON(
  jsonString: string,
): SafeParseResult<BasicAuthOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BasicAuthOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BasicAuthOptions' from JSON`,
  );
}

/** @internal */
export const BulkWriteSupport$inboundSchema: z.ZodType<
  BulkWriteSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  insert: z.boolean(),
  update: z.boolean(),
  upsert: z.boolean(),
  delete: z.boolean(),
});

/** @internal */
export type BulkWriteSupport$Outbound = {
  insert: boolean;
  update: boolean;
  upsert: boolean;
  delete: boolean;
};

/** @internal */
export const BulkWriteSupport$outboundSchema: z.ZodType<
  BulkWriteSupport$Outbound,
  z.ZodTypeDef,
  BulkWriteSupport
> = z.object({
  insert: z.boolean(),
  update: z.boolean(),
  upsert: z.boolean(),
  delete: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkWriteSupport$ {
  /** @deprecated use `BulkWriteSupport$inboundSchema` instead. */
  export const inboundSchema = BulkWriteSupport$inboundSchema;
  /** @deprecated use `BulkWriteSupport$outboundSchema` instead. */
  export const outboundSchema = BulkWriteSupport$outboundSchema;
  /** @deprecated use `BulkWriteSupport$Outbound` instead. */
  export type Outbound = BulkWriteSupport$Outbound;
}

export function bulkWriteSupportToJSON(
  bulkWriteSupport: BulkWriteSupport,
): string {
  return JSON.stringify(
    BulkWriteSupport$outboundSchema.parse(bulkWriteSupport),
  );
}

export function bulkWriteSupportFromJSON(
  jsonString: string,
): SafeParseResult<BulkWriteSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkWriteSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkWriteSupport' from JSON`,
  );
}

/** @internal */
export const SubscribeSupport$inboundSchema: z.ZodType<
  SubscribeSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  create: z.boolean().optional(),
  update: z.boolean().optional(),
  delete: z.boolean().optional(),
  passThrough: z.boolean().optional(),
});

/** @internal */
export type SubscribeSupport$Outbound = {
  create?: boolean | undefined;
  update?: boolean | undefined;
  delete?: boolean | undefined;
  passThrough?: boolean | undefined;
};

/** @internal */
export const SubscribeSupport$outboundSchema: z.ZodType<
  SubscribeSupport$Outbound,
  z.ZodTypeDef,
  SubscribeSupport
> = z.object({
  create: z.boolean().optional(),
  update: z.boolean().optional(),
  delete: z.boolean().optional(),
  passThrough: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribeSupport$ {
  /** @deprecated use `SubscribeSupport$inboundSchema` instead. */
  export const inboundSchema = SubscribeSupport$inboundSchema;
  /** @deprecated use `SubscribeSupport$outboundSchema` instead. */
  export const outboundSchema = SubscribeSupport$outboundSchema;
  /** @deprecated use `SubscribeSupport$Outbound` instead. */
  export type Outbound = SubscribeSupport$Outbound;
}

export function subscribeSupportToJSON(
  subscribeSupport: SubscribeSupport,
): string {
  return JSON.stringify(
    SubscribeSupport$outboundSchema.parse(subscribeSupport),
  );
}

export function subscribeSupportFromJSON(
  jsonString: string,
): SafeParseResult<SubscribeSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribeSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribeSupport' from JSON`,
  );
}

/** @internal */
export const Support$inboundSchema: z.ZodType<Support, z.ZodTypeDef, unknown> =
  z.object({
    bulkWrite: z.lazy(() => BulkWriteSupport$inboundSchema),
    proxy: z.boolean(),
    read: z.boolean(),
    subscribe: z.boolean(),
    write: z.boolean(),
    subscribeSupport: z.lazy(() => SubscribeSupport$inboundSchema).optional(),
  });

/** @internal */
export type Support$Outbound = {
  bulkWrite: BulkWriteSupport$Outbound;
  proxy: boolean;
  read: boolean;
  subscribe: boolean;
  write: boolean;
  subscribeSupport?: SubscribeSupport$Outbound | undefined;
};

/** @internal */
export const Support$outboundSchema: z.ZodType<
  Support$Outbound,
  z.ZodTypeDef,
  Support
> = z.object({
  bulkWrite: z.lazy(() => BulkWriteSupport$outboundSchema),
  proxy: z.boolean(),
  read: z.boolean(),
  subscribe: z.boolean(),
  write: z.boolean(),
  subscribeSupport: z.lazy(() => SubscribeSupport$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Support$ {
  /** @deprecated use `Support$inboundSchema` instead. */
  export const inboundSchema = Support$inboundSchema;
  /** @deprecated use `Support$outboundSchema` instead. */
  export const outboundSchema = Support$outboundSchema;
  /** @deprecated use `Support$Outbound` instead. */
  export type Outbound = Support$Outbound;
}

export function supportToJSON(support: Support): string {
  return JSON.stringify(Support$outboundSchema.parse(support));
}

export function supportFromJSON(
  jsonString: string,
): SafeParseResult<Support, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Support$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Support' from JSON`,
  );
}

/** @internal */
export const AuthHealthCheck$inboundSchema: z.ZodType<
  AuthHealthCheck,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: z.string().optional(),
  successStatusCodes: z.array(z.number().int()).optional(),
});

/** @internal */
export type AuthHealthCheck$Outbound = {
  url: string;
  method?: string | undefined;
  successStatusCodes?: Array<number> | undefined;
};

/** @internal */
export const AuthHealthCheck$outboundSchema: z.ZodType<
  AuthHealthCheck$Outbound,
  z.ZodTypeDef,
  AuthHealthCheck
> = z.object({
  url: z.string(),
  method: z.string().optional(),
  successStatusCodes: z.array(z.number().int()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthHealthCheck$ {
  /** @deprecated use `AuthHealthCheck$inboundSchema` instead. */
  export const inboundSchema = AuthHealthCheck$inboundSchema;
  /** @deprecated use `AuthHealthCheck$outboundSchema` instead. */
  export const outboundSchema = AuthHealthCheck$outboundSchema;
  /** @deprecated use `AuthHealthCheck$Outbound` instead. */
  export type Outbound = AuthHealthCheck$Outbound;
}

export function authHealthCheckToJSON(
  authHealthCheck: AuthHealthCheck,
): string {
  return JSON.stringify(AuthHealthCheck$outboundSchema.parse(authHealthCheck));
}

export function authHealthCheckFromJSON(
  jsonString: string,
): SafeParseResult<AuthHealthCheck, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthHealthCheck$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthHealthCheck' from JSON`,
  );
}

/** @internal */
export const MediaTypeRegular$inboundSchema: z.ZodType<
  MediaTypeRegular,
  z.ZodTypeDef,
  unknown
> = z.object({
  iconURL: z.string().optional(),
  logoURL: z.string().optional(),
});

/** @internal */
export type MediaTypeRegular$Outbound = {
  iconURL?: string | undefined;
  logoURL?: string | undefined;
};

/** @internal */
export const MediaTypeRegular$outboundSchema: z.ZodType<
  MediaTypeRegular$Outbound,
  z.ZodTypeDef,
  MediaTypeRegular
> = z.object({
  iconURL: z.string().optional(),
  logoURL: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaTypeRegular$ {
  /** @deprecated use `MediaTypeRegular$inboundSchema` instead. */
  export const inboundSchema = MediaTypeRegular$inboundSchema;
  /** @deprecated use `MediaTypeRegular$outboundSchema` instead. */
  export const outboundSchema = MediaTypeRegular$outboundSchema;
  /** @deprecated use `MediaTypeRegular$Outbound` instead. */
  export type Outbound = MediaTypeRegular$Outbound;
}

export function mediaTypeRegularToJSON(
  mediaTypeRegular: MediaTypeRegular,
): string {
  return JSON.stringify(
    MediaTypeRegular$outboundSchema.parse(mediaTypeRegular),
  );
}

export function mediaTypeRegularFromJSON(
  jsonString: string,
): SafeParseResult<MediaTypeRegular, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaTypeRegular$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaTypeRegular' from JSON`,
  );
}

/** @internal */
export const MediaTypeDarkMode$inboundSchema: z.ZodType<
  MediaTypeDarkMode,
  z.ZodTypeDef,
  unknown
> = z.object({
  iconURL: z.string().optional(),
  logoURL: z.string().optional(),
});

/** @internal */
export type MediaTypeDarkMode$Outbound = {
  iconURL?: string | undefined;
  logoURL?: string | undefined;
};

/** @internal */
export const MediaTypeDarkMode$outboundSchema: z.ZodType<
  MediaTypeDarkMode$Outbound,
  z.ZodTypeDef,
  MediaTypeDarkMode
> = z.object({
  iconURL: z.string().optional(),
  logoURL: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaTypeDarkMode$ {
  /** @deprecated use `MediaTypeDarkMode$inboundSchema` instead. */
  export const inboundSchema = MediaTypeDarkMode$inboundSchema;
  /** @deprecated use `MediaTypeDarkMode$outboundSchema` instead. */
  export const outboundSchema = MediaTypeDarkMode$outboundSchema;
  /** @deprecated use `MediaTypeDarkMode$Outbound` instead. */
  export type Outbound = MediaTypeDarkMode$Outbound;
}

export function mediaTypeDarkModeToJSON(
  mediaTypeDarkMode: MediaTypeDarkMode,
): string {
  return JSON.stringify(
    MediaTypeDarkMode$outboundSchema.parse(mediaTypeDarkMode),
  );
}

export function mediaTypeDarkModeFromJSON(
  jsonString: string,
): SafeParseResult<MediaTypeDarkMode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaTypeDarkMode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaTypeDarkMode' from JSON`,
  );
}

/** @internal */
export const Media$inboundSchema: z.ZodType<Media, z.ZodTypeDef, unknown> = z
  .object({
    regular: z.lazy(() => MediaTypeRegular$inboundSchema).optional(),
    darkMode: z.lazy(() => MediaTypeDarkMode$inboundSchema).optional(),
  });

/** @internal */
export type Media$Outbound = {
  regular?: MediaTypeRegular$Outbound | undefined;
  darkMode?: MediaTypeDarkMode$Outbound | undefined;
};

/** @internal */
export const Media$outboundSchema: z.ZodType<
  Media$Outbound,
  z.ZodTypeDef,
  Media
> = z.object({
  regular: z.lazy(() => MediaTypeRegular$outboundSchema).optional(),
  darkMode: z.lazy(() => MediaTypeDarkMode$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Media$ {
  /** @deprecated use `Media$inboundSchema` instead. */
  export const inboundSchema = Media$inboundSchema;
  /** @deprecated use `Media$outboundSchema` instead. */
  export const outboundSchema = Media$outboundSchema;
  /** @deprecated use `Media$Outbound` instead. */
  export type Outbound = Media$Outbound;
}

export function mediaToJSON(media: Media): string {
  return JSON.stringify(Media$outboundSchema.parse(media));
}

export function mediaFromJSON(
  jsonString: string,
): SafeParseResult<Media, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Media$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Media' from JSON`,
  );
}

/** @internal */
export const SubscriptionScope$inboundSchema: z.ZodNativeEnum<
  typeof SubscriptionScope
> = z.nativeEnum(SubscriptionScope);

/** @internal */
export const SubscriptionScope$outboundSchema: z.ZodNativeEnum<
  typeof SubscriptionScope
> = SubscriptionScope$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionScope$ {
  /** @deprecated use `SubscriptionScope$inboundSchema` instead. */
  export const inboundSchema = SubscriptionScope$inboundSchema;
  /** @deprecated use `SubscriptionScope$outboundSchema` instead. */
  export const outboundSchema = SubscriptionScope$outboundSchema;
}

/** @internal */
export const TargetURLScope$inboundSchema: z.ZodNativeEnum<
  typeof TargetURLScope
> = z.nativeEnum(TargetURLScope);

/** @internal */
export const TargetURLScope$outboundSchema: z.ZodNativeEnum<
  typeof TargetURLScope
> = TargetURLScope$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TargetURLScope$ {
  /** @deprecated use `TargetURLScope$inboundSchema` instead. */
  export const inboundSchema = TargetURLScope$inboundSchema;
  /** @deprecated use `TargetURLScope$outboundSchema` instead. */
  export const outboundSchema = TargetURLScope$outboundSchema;
}

/** @internal */
export const RegistrationTiming$inboundSchema: z.ZodNativeEnum<
  typeof RegistrationTiming
> = z.nativeEnum(RegistrationTiming);

/** @internal */
export const RegistrationTiming$outboundSchema: z.ZodNativeEnum<
  typeof RegistrationTiming
> = RegistrationTiming$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RegistrationTiming$ {
  /** @deprecated use `RegistrationTiming$inboundSchema` instead. */
  export const inboundSchema = RegistrationTiming$inboundSchema;
  /** @deprecated use `RegistrationTiming$outboundSchema` instead. */
  export const outboundSchema = RegistrationTiming$outboundSchema;
}

/** @internal */
export const SubscribeOptions$inboundSchema: z.ZodType<
  SubscribeOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  subscriptionScope: SubscriptionScope$inboundSchema,
  targetURLScope: TargetURLScope$inboundSchema,
  registrationTiming: RegistrationTiming$inboundSchema,
});

/** @internal */
export type SubscribeOptions$Outbound = {
  subscriptionScope: string;
  targetURLScope: string;
  registrationTiming: string;
};

/** @internal */
export const SubscribeOptions$outboundSchema: z.ZodType<
  SubscribeOptions$Outbound,
  z.ZodTypeDef,
  SubscribeOptions
> = z.object({
  subscriptionScope: SubscriptionScope$outboundSchema,
  targetURLScope: TargetURLScope$outboundSchema,
  registrationTiming: RegistrationTiming$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribeOptions$ {
  /** @deprecated use `SubscribeOptions$inboundSchema` instead. */
  export const inboundSchema = SubscribeOptions$inboundSchema;
  /** @deprecated use `SubscribeOptions$outboundSchema` instead. */
  export const outboundSchema = SubscribeOptions$outboundSchema;
  /** @deprecated use `SubscribeOptions$Outbound` instead. */
  export type Outbound = SubscribeOptions$Outbound;
}

export function subscribeOptionsToJSON(
  subscribeOptions: SubscribeOptions,
): string {
  return JSON.stringify(
    SubscribeOptions$outboundSchema.parse(subscribeOptions),
  );
}

export function subscribeOptionsFromJSON(
  jsonString: string,
): SafeParseResult<SubscribeOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribeOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribeOptions' from JSON`,
  );
}

/** @internal */
export const ListProvidersBulkWriteSupport$inboundSchema: z.ZodType<
  ListProvidersBulkWriteSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  insert: z.boolean(),
  update: z.boolean(),
  upsert: z.boolean(),
  delete: z.boolean(),
});

/** @internal */
export type ListProvidersBulkWriteSupport$Outbound = {
  insert: boolean;
  update: boolean;
  upsert: boolean;
  delete: boolean;
};

/** @internal */
export const ListProvidersBulkWriteSupport$outboundSchema: z.ZodType<
  ListProvidersBulkWriteSupport$Outbound,
  z.ZodTypeDef,
  ListProvidersBulkWriteSupport
> = z.object({
  insert: z.boolean(),
  update: z.boolean(),
  upsert: z.boolean(),
  delete: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersBulkWriteSupport$ {
  /** @deprecated use `ListProvidersBulkWriteSupport$inboundSchema` instead. */
  export const inboundSchema = ListProvidersBulkWriteSupport$inboundSchema;
  /** @deprecated use `ListProvidersBulkWriteSupport$outboundSchema` instead. */
  export const outboundSchema = ListProvidersBulkWriteSupport$outboundSchema;
  /** @deprecated use `ListProvidersBulkWriteSupport$Outbound` instead. */
  export type Outbound = ListProvidersBulkWriteSupport$Outbound;
}

export function listProvidersBulkWriteSupportToJSON(
  listProvidersBulkWriteSupport: ListProvidersBulkWriteSupport,
): string {
  return JSON.stringify(
    ListProvidersBulkWriteSupport$outboundSchema.parse(
      listProvidersBulkWriteSupport,
    ),
  );
}

export function listProvidersBulkWriteSupportFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersBulkWriteSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersBulkWriteSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersBulkWriteSupport' from JSON`,
  );
}

/** @internal */
export const ListProvidersSubscribeSupport$inboundSchema: z.ZodType<
  ListProvidersSubscribeSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  create: z.boolean().optional(),
  update: z.boolean().optional(),
  delete: z.boolean().optional(),
  passThrough: z.boolean().optional(),
});

/** @internal */
export type ListProvidersSubscribeSupport$Outbound = {
  create?: boolean | undefined;
  update?: boolean | undefined;
  delete?: boolean | undefined;
  passThrough?: boolean | undefined;
};

/** @internal */
export const ListProvidersSubscribeSupport$outboundSchema: z.ZodType<
  ListProvidersSubscribeSupport$Outbound,
  z.ZodTypeDef,
  ListProvidersSubscribeSupport
> = z.object({
  create: z.boolean().optional(),
  update: z.boolean().optional(),
  delete: z.boolean().optional(),
  passThrough: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersSubscribeSupport$ {
  /** @deprecated use `ListProvidersSubscribeSupport$inboundSchema` instead. */
  export const inboundSchema = ListProvidersSubscribeSupport$inboundSchema;
  /** @deprecated use `ListProvidersSubscribeSupport$outboundSchema` instead. */
  export const outboundSchema = ListProvidersSubscribeSupport$outboundSchema;
  /** @deprecated use `ListProvidersSubscribeSupport$Outbound` instead. */
  export type Outbound = ListProvidersSubscribeSupport$Outbound;
}

export function listProvidersSubscribeSupportToJSON(
  listProvidersSubscribeSupport: ListProvidersSubscribeSupport,
): string {
  return JSON.stringify(
    ListProvidersSubscribeSupport$outboundSchema.parse(
      listProvidersSubscribeSupport,
    ),
  );
}

export function listProvidersSubscribeSupportFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersSubscribeSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersSubscribeSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersSubscribeSupport' from JSON`,
  );
}

/** @internal */
export const ListProvidersSupport$inboundSchema: z.ZodType<
  ListProvidersSupport,
  z.ZodTypeDef,
  unknown
> = z.object({
  bulkWrite: z.lazy(() => ListProvidersBulkWriteSupport$inboundSchema),
  proxy: z.boolean(),
  read: z.boolean(),
  subscribe: z.boolean(),
  write: z.boolean(),
  subscribeSupport: z.lazy(() => ListProvidersSubscribeSupport$inboundSchema)
    .optional(),
});

/** @internal */
export type ListProvidersSupport$Outbound = {
  bulkWrite: ListProvidersBulkWriteSupport$Outbound;
  proxy: boolean;
  read: boolean;
  subscribe: boolean;
  write: boolean;
  subscribeSupport?: ListProvidersSubscribeSupport$Outbound | undefined;
};

/** @internal */
export const ListProvidersSupport$outboundSchema: z.ZodType<
  ListProvidersSupport$Outbound,
  z.ZodTypeDef,
  ListProvidersSupport
> = z.object({
  bulkWrite: z.lazy(() => ListProvidersBulkWriteSupport$outboundSchema),
  proxy: z.boolean(),
  read: z.boolean(),
  subscribe: z.boolean(),
  write: z.boolean(),
  subscribeSupport: z.lazy(() => ListProvidersSubscribeSupport$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersSupport$ {
  /** @deprecated use `ListProvidersSupport$inboundSchema` instead. */
  export const inboundSchema = ListProvidersSupport$inboundSchema;
  /** @deprecated use `ListProvidersSupport$outboundSchema` instead. */
  export const outboundSchema = ListProvidersSupport$outboundSchema;
  /** @deprecated use `ListProvidersSupport$Outbound` instead. */
  export type Outbound = ListProvidersSupport$Outbound;
}

export function listProvidersSupportToJSON(
  listProvidersSupport: ListProvidersSupport,
): string {
  return JSON.stringify(
    ListProvidersSupport$outboundSchema.parse(listProvidersSupport),
  );
}

export function listProvidersSupportFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersSupport, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersSupport$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersSupport' from JSON`,
  );
}

/** @internal */
export const ModuleInfo$inboundSchema: z.ZodType<
  ModuleInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  displayName: z.string(),
  baseURL: z.string(),
  support: z.lazy(() => ListProvidersSupport$inboundSchema),
});

/** @internal */
export type ModuleInfo$Outbound = {
  displayName: string;
  baseURL: string;
  support: ListProvidersSupport$Outbound;
};

/** @internal */
export const ModuleInfo$outboundSchema: z.ZodType<
  ModuleInfo$Outbound,
  z.ZodTypeDef,
  ModuleInfo
> = z.object({
  displayName: z.string(),
  baseURL: z.string(),
  support: z.lazy(() => ListProvidersSupport$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModuleInfo$ {
  /** @deprecated use `ModuleInfo$inboundSchema` instead. */
  export const inboundSchema = ModuleInfo$inboundSchema;
  /** @deprecated use `ModuleInfo$outboundSchema` instead. */
  export const outboundSchema = ModuleInfo$outboundSchema;
  /** @deprecated use `ModuleInfo$Outbound` instead. */
  export type Outbound = ModuleInfo$Outbound;
}

export function moduleInfoToJSON(moduleInfo: ModuleInfo): string {
  return JSON.stringify(ModuleInfo$outboundSchema.parse(moduleInfo));
}

export function moduleInfoFromJSON(
  jsonString: string,
): SafeParseResult<ModuleInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModuleInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModuleInfo' from JSON`,
  );
}

/** @internal */
export const ModuleDependency$inboundSchema: z.ZodType<
  ModuleDependency,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ModuleDependency$Outbound = {};

/** @internal */
export const ModuleDependency$outboundSchema: z.ZodType<
  ModuleDependency$Outbound,
  z.ZodTypeDef,
  ModuleDependency
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ModuleDependency$ {
  /** @deprecated use `ModuleDependency$inboundSchema` instead. */
  export const inboundSchema = ModuleDependency$inboundSchema;
  /** @deprecated use `ModuleDependency$outboundSchema` instead. */
  export const outboundSchema = ModuleDependency$outboundSchema;
  /** @deprecated use `ModuleDependency$Outbound` instead. */
  export type Outbound = ModuleDependency$Outbound;
}

export function moduleDependencyToJSON(
  moduleDependency: ModuleDependency,
): string {
  return JSON.stringify(
    ModuleDependency$outboundSchema.parse(moduleDependency),
  );
}

export function moduleDependencyFromJSON(
  jsonString: string,
): SafeParseResult<ModuleDependency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModuleDependency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModuleDependency' from JSON`,
  );
}

/** @internal */
export const MetadataItemAsInput$inboundSchema: z.ZodType<
  MetadataItemAsInput,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  displayName: z.string().optional(),
  docsURL: z.string().optional(),
  moduleDependencies: z.record(z.lazy(() => ModuleDependency$inboundSchema))
    .optional(),
});

/** @internal */
export type MetadataItemAsInput$Outbound = {
  name: string;
  displayName?: string | undefined;
  docsURL?: string | undefined;
  moduleDependencies?: { [k: string]: ModuleDependency$Outbound } | undefined;
};

/** @internal */
export const MetadataItemAsInput$outboundSchema: z.ZodType<
  MetadataItemAsInput$Outbound,
  z.ZodTypeDef,
  MetadataItemAsInput
> = z.object({
  name: z.string(),
  displayName: z.string().optional(),
  docsURL: z.string().optional(),
  moduleDependencies: z.record(z.lazy(() => ModuleDependency$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadataItemAsInput$ {
  /** @deprecated use `MetadataItemAsInput$inboundSchema` instead. */
  export const inboundSchema = MetadataItemAsInput$inboundSchema;
  /** @deprecated use `MetadataItemAsInput$outboundSchema` instead. */
  export const outboundSchema = MetadataItemAsInput$outboundSchema;
  /** @deprecated use `MetadataItemAsInput$Outbound` instead. */
  export type Outbound = MetadataItemAsInput$Outbound;
}

export function metadataItemAsInputToJSON(
  metadataItemAsInput: MetadataItemAsInput,
): string {
  return JSON.stringify(
    MetadataItemAsInput$outboundSchema.parse(metadataItemAsInput),
  );
}

export function metadataItemAsInputFromJSON(
  jsonString: string,
): SafeParseResult<MetadataItemAsInput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetadataItemAsInput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadataItemAsInput' from JSON`,
  );
}

/** @internal */
export const ListProvidersModuleDependency$inboundSchema: z.ZodType<
  ListProvidersModuleDependency,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ListProvidersModuleDependency$Outbound = {};

/** @internal */
export const ListProvidersModuleDependency$outboundSchema: z.ZodType<
  ListProvidersModuleDependency$Outbound,
  z.ZodTypeDef,
  ListProvidersModuleDependency
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersModuleDependency$ {
  /** @deprecated use `ListProvidersModuleDependency$inboundSchema` instead. */
  export const inboundSchema = ListProvidersModuleDependency$inboundSchema;
  /** @deprecated use `ListProvidersModuleDependency$outboundSchema` instead. */
  export const outboundSchema = ListProvidersModuleDependency$outboundSchema;
  /** @deprecated use `ListProvidersModuleDependency$Outbound` instead. */
  export type Outbound = ListProvidersModuleDependency$Outbound;
}

export function listProvidersModuleDependencyToJSON(
  listProvidersModuleDependency: ListProvidersModuleDependency,
): string {
  return JSON.stringify(
    ListProvidersModuleDependency$outboundSchema.parse(
      listProvidersModuleDependency,
    ),
  );
}

export function listProvidersModuleDependencyFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersModuleDependency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersModuleDependency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersModuleDependency' from JSON`,
  );
}

/** @internal */
export const MetadataItemFetchedPostAuthentication$inboundSchema: z.ZodType<
  MetadataItemFetchedPostAuthentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  moduleDependencies: z.record(
    z.lazy(() => ListProvidersModuleDependency$inboundSchema),
  ).optional(),
});

/** @internal */
export type MetadataItemFetchedPostAuthentication$Outbound = {
  name: string;
  moduleDependencies?:
    | { [k: string]: ListProvidersModuleDependency$Outbound }
    | undefined;
};

/** @internal */
export const MetadataItemFetchedPostAuthentication$outboundSchema: z.ZodType<
  MetadataItemFetchedPostAuthentication$Outbound,
  z.ZodTypeDef,
  MetadataItemFetchedPostAuthentication
> = z.object({
  name: z.string(),
  moduleDependencies: z.record(
    z.lazy(() => ListProvidersModuleDependency$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetadataItemFetchedPostAuthentication$ {
  /** @deprecated use `MetadataItemFetchedPostAuthentication$inboundSchema` instead. */
  export const inboundSchema =
    MetadataItemFetchedPostAuthentication$inboundSchema;
  /** @deprecated use `MetadataItemFetchedPostAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    MetadataItemFetchedPostAuthentication$outboundSchema;
  /** @deprecated use `MetadataItemFetchedPostAuthentication$Outbound` instead. */
  export type Outbound = MetadataItemFetchedPostAuthentication$Outbound;
}

export function metadataItemFetchedPostAuthenticationToJSON(
  metadataItemFetchedPostAuthentication: MetadataItemFetchedPostAuthentication,
): string {
  return JSON.stringify(
    MetadataItemFetchedPostAuthentication$outboundSchema.parse(
      metadataItemFetchedPostAuthentication,
    ),
  );
}

export function metadataItemFetchedPostAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<MetadataItemFetchedPostAuthentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      MetadataItemFetchedPostAuthentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetadataItemFetchedPostAuthentication' from JSON`,
  );
}

/** @internal */
export const ProviderMetadata$inboundSchema: z.ZodType<
  ProviderMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  input: z.array(z.lazy(() => MetadataItemAsInput$inboundSchema)).optional(),
  postAuthentication: z.array(
    z.lazy(() => MetadataItemFetchedPostAuthentication$inboundSchema),
  ).optional(),
});

/** @internal */
export type ProviderMetadata$Outbound = {
  input?: Array<MetadataItemAsInput$Outbound> | undefined;
  postAuthentication?:
    | Array<MetadataItemFetchedPostAuthentication$Outbound>
    | undefined;
};

/** @internal */
export const ProviderMetadata$outboundSchema: z.ZodType<
  ProviderMetadata$Outbound,
  z.ZodTypeDef,
  ProviderMetadata
> = z.object({
  input: z.array(z.lazy(() => MetadataItemAsInput$outboundSchema)).optional(),
  postAuthentication: z.array(
    z.lazy(() => MetadataItemFetchedPostAuthentication$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProviderMetadata$ {
  /** @deprecated use `ProviderMetadata$inboundSchema` instead. */
  export const inboundSchema = ProviderMetadata$inboundSchema;
  /** @deprecated use `ProviderMetadata$outboundSchema` instead. */
  export const outboundSchema = ProviderMetadata$outboundSchema;
  /** @deprecated use `ProviderMetadata$Outbound` instead. */
  export type Outbound = ProviderMetadata$Outbound;
}

export function providerMetadataToJSON(
  providerMetadata: ProviderMetadata,
): string {
  return JSON.stringify(
    ProviderMetadata$outboundSchema.parse(providerMetadata),
  );
}

export function providerMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ProviderMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProviderMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProviderMetadata' from JSON`,
  );
}

/** @internal */
export const ProviderInfo$inboundSchema: z.ZodType<
  ProviderInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  authType: AuthType$inboundSchema,
  baseURL: z.string(),
  defaultModule: z.any().optional(),
  oauth2Opts: z.lazy(() => OAuth2Options$inboundSchema).optional(),
  apiKeyOpts: z.lazy(() => APIKeyOptions$inboundSchema).optional(),
  basicOpts: z.lazy(() => BasicAuthOptions$inboundSchema).optional(),
  support: z.lazy(() => Support$inboundSchema),
  providerOpts: z.record(z.string()),
  authHealthCheck: z.lazy(() => AuthHealthCheck$inboundSchema).optional(),
  displayName: z.string().optional(),
  postAuthInfoNeeded: z.boolean().optional(),
  media: z.lazy(() => Media$inboundSchema).optional(),
  labels: z.record(z.string()).optional(),
  subscribeOpts: z.lazy(() => SubscribeOptions$inboundSchema).optional(),
  modules: z.record(z.lazy(() => ModuleInfo$inboundSchema)).optional(),
  metadata: z.lazy(() => ProviderMetadata$inboundSchema).optional(),
});

/** @internal */
export type ProviderInfo$Outbound = {
  name: string;
  authType: string;
  baseURL: string;
  defaultModule?: any | undefined;
  oauth2Opts?: OAuth2Options$Outbound | undefined;
  apiKeyOpts?: APIKeyOptions$Outbound | undefined;
  basicOpts?: BasicAuthOptions$Outbound | undefined;
  support: Support$Outbound;
  providerOpts: { [k: string]: string };
  authHealthCheck?: AuthHealthCheck$Outbound | undefined;
  displayName?: string | undefined;
  postAuthInfoNeeded?: boolean | undefined;
  media?: Media$Outbound | undefined;
  labels?: { [k: string]: string } | undefined;
  subscribeOpts?: SubscribeOptions$Outbound | undefined;
  modules?: { [k: string]: ModuleInfo$Outbound } | undefined;
  metadata?: ProviderMetadata$Outbound | undefined;
};

/** @internal */
export const ProviderInfo$outboundSchema: z.ZodType<
  ProviderInfo$Outbound,
  z.ZodTypeDef,
  ProviderInfo
> = z.object({
  name: z.string(),
  authType: AuthType$outboundSchema,
  baseURL: z.string(),
  defaultModule: z.any().optional(),
  oauth2Opts: z.lazy(() => OAuth2Options$outboundSchema).optional(),
  apiKeyOpts: z.lazy(() => APIKeyOptions$outboundSchema).optional(),
  basicOpts: z.lazy(() => BasicAuthOptions$outboundSchema).optional(),
  support: z.lazy(() => Support$outboundSchema),
  providerOpts: z.record(z.string()),
  authHealthCheck: z.lazy(() => AuthHealthCheck$outboundSchema).optional(),
  displayName: z.string().optional(),
  postAuthInfoNeeded: z.boolean().optional(),
  media: z.lazy(() => Media$outboundSchema).optional(),
  labels: z.record(z.string()).optional(),
  subscribeOpts: z.lazy(() => SubscribeOptions$outboundSchema).optional(),
  modules: z.record(z.lazy(() => ModuleInfo$outboundSchema)).optional(),
  metadata: z.lazy(() => ProviderMetadata$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProviderInfo$ {
  /** @deprecated use `ProviderInfo$inboundSchema` instead. */
  export const inboundSchema = ProviderInfo$inboundSchema;
  /** @deprecated use `ProviderInfo$outboundSchema` instead. */
  export const outboundSchema = ProviderInfo$outboundSchema;
  /** @deprecated use `ProviderInfo$Outbound` instead. */
  export type Outbound = ProviderInfo$Outbound;
}

export function providerInfoToJSON(providerInfo: ProviderInfo): string {
  return JSON.stringify(ProviderInfo$outboundSchema.parse(providerInfo));
}

export function providerInfoFromJSON(
  jsonString: string,
): SafeParseResult<ProviderInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProviderInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProviderInfo' from JSON`,
  );
}

/** @internal */
export const ListProvidersResponse$inboundSchema: z.ZodType<
  ListProvidersResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListProvidersAPIProblem$inboundSchema),
  z.record(z.lazy(() => ProviderInfo$inboundSchema)),
]);

/** @internal */
export type ListProvidersResponse$Outbound =
  | ListProvidersAPIProblem$Outbound
  | { [k: string]: ProviderInfo$Outbound };

/** @internal */
export const ListProvidersResponse$outboundSchema: z.ZodType<
  ListProvidersResponse$Outbound,
  z.ZodTypeDef,
  ListProvidersResponse
> = z.union([
  z.lazy(() => ListProvidersAPIProblem$outboundSchema),
  z.record(z.lazy(() => ProviderInfo$outboundSchema)),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListProvidersResponse$ {
  /** @deprecated use `ListProvidersResponse$inboundSchema` instead. */
  export const inboundSchema = ListProvidersResponse$inboundSchema;
  /** @deprecated use `ListProvidersResponse$outboundSchema` instead. */
  export const outboundSchema = ListProvidersResponse$outboundSchema;
  /** @deprecated use `ListProvidersResponse$Outbound` instead. */
  export type Outbound = ListProvidersResponse$Outbound;
}

export function listProvidersResponseToJSON(
  listProvidersResponse: ListProvidersResponse,
): string {
  return JSON.stringify(
    ListProvidersResponse$outboundSchema.parse(listProvidersResponse),
  );
}

export function listProvidersResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListProvidersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListProvidersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListProvidersResponse' from JSON`,
  );
}
