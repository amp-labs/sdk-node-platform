/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type IntegrationFieldMapping = {
  mapToName: string;
  mapToDisplayName?: string | undefined;
  default?: string | undefined;
  prompt?: string | undefined;
};

export type IntegrationFieldExistent = {
  fieldName: string;
  /**
   * The field name to map to.
   */
  mapToName?: string | undefined;
  /**
   * The display name to map to.
   */
  mapToDisplayName?: string | undefined;
};

export type IntegrationField =
  | IntegrationFieldExistent
  | IntegrationFieldMapping;

export type IntegrationFieldIntegrationFieldMapping = {
  mapToName: string;
  mapToDisplayName?: string | undefined;
  default?: string | undefined;
  prompt?: string | undefined;
};

export type IntegrationFieldIntegrationFieldExistent = {
  fieldName: string;
  /**
   * The field name to map to.
   */
  mapToName?: string | undefined;
  /**
   * The display name to map to.
   */
  mapToDisplayName?: string | undefined;
};

export type CreateIntegrationIntegrationField =
  | IntegrationFieldIntegrationFieldExistent
  | IntegrationFieldIntegrationFieldMapping;

export const OptionalFieldsAutoOption = {
  All: "all",
} as const;
export type OptionalFieldsAutoOption = ClosedEnum<
  typeof OptionalFieldsAutoOption
>;

export type DefaultPeriod = {
  /**
   * Number of days in past to backfill from. 0 is no backfill. e.g) if 10, then backfill last 10 days of data. Required if fullHistory is not set.
   */
  days?: number | undefined;
  /**
   * If true, backfill all history. Required if days is not set.
   */
  fullHistory?: boolean | undefined;
};

export type Backfill = {
  defaultPeriod: DefaultPeriod;
};

/**
 * The data delivery mode for this object. If not specified, defaults to automatic.
 */
export const Mode = {
  OnRequest: "onRequest",
  Auto: "auto",
} as const;
/**
 * The data delivery mode for this object. If not specified, defaults to automatic.
 */
export type Mode = ClosedEnum<typeof Mode>;

export type Delivery = {
  /**
   * The data delivery mode for this object. If not specified, defaults to automatic.
   */
  mode?: Mode | undefined;
  /**
   * The number of records to receive per data delivery.
   */
  pageSize?: number | undefined;
};

export type IntegrationObject = {
  objectName: string;
  destination: string;
  schedule: string;
  /**
   * An object name to map to.
   */
  mapToName?: string | undefined;
  /**
   * A display name to map to.
   */
  mapToDisplayName?: string | undefined;
  requiredFields?:
    | Array<IntegrationFieldExistent | IntegrationFieldMapping>
    | undefined;
  optionalFields?:
    | Array<
      | IntegrationFieldIntegrationFieldExistent
      | IntegrationFieldIntegrationFieldMapping
    >
    | undefined;
  optionalFieldsAuto?: OptionalFieldsAutoOption | undefined;
  backfill?: Backfill | undefined;
  delivery?: Delivery | undefined;
};

export type ReadIntegration = {
  objects?: Array<IntegrationObject> | undefined;
};

/**
 * Configuration to set default write values for object fields.
 */
export type ValueDefaults = {
  /**
   * If true, users can set default values for any field.
   */
  allowAnyFields?: boolean | undefined;
};

export type IntegrationWriteObject = {
  objectName: string;
  /**
   * If true, the write object will inherit the mapping from the read object. If false, the write object will have no mapping.
   */
  inheritMapping?: boolean | undefined;
  /**
   * Configuration to set default write values for object fields.
   */
  valueDefaults?: ValueDefaults | undefined;
};

export type WriteIntegration = {
  objects?: Array<IntegrationWriteObject> | undefined;
};

export type ProxyIntegration = {
  enabled?: boolean | undefined;
};

/**
 * If always, the integration will subscribe to create events.
 */
export const Enabled = {
  Always: "always",
} as const;
/**
 * If always, the integration will subscribe to create events.
 */
export type Enabled = ClosedEnum<typeof Enabled>;

export type CreateEvent = {
  /**
   * If always, the integration will subscribe to create events.
   */
  enabled?: Enabled | undefined;
};

/**
 * If always, the integration will subscribe to update events.
 */
export const CreateIntegrationEnabled = {
  Always: "always",
} as const;
/**
 * If always, the integration will subscribe to update events.
 */
export type CreateIntegrationEnabled = ClosedEnum<
  typeof CreateIntegrationEnabled
>;

/**
 * If all, the integration will watch all fields for updates.
 */
export const WatchFieldsAuto = {
  All: "all",
} as const;
/**
 * If all, the integration will watch all fields for updates.
 */
export type WatchFieldsAuto = ClosedEnum<typeof WatchFieldsAuto>;

export type UpdateEvent = {
  /**
   * If always, the integration will subscribe to update events.
   */
  enabled?: CreateIntegrationEnabled | undefined;
  /**
   * If all, the integration will watch all fields for updates.
   */
  watchFieldsAuto?: WatchFieldsAuto | undefined;
  requiredWatchFields?: Array<string> | undefined;
};

/**
 * If always, the integration will subscribe to delete events.
 */
export const CreateIntegrationIntegrationsEnabled = {
  Always: "always",
} as const;
/**
 * If always, the integration will subscribe to delete events.
 */
export type CreateIntegrationIntegrationsEnabled = ClosedEnum<
  typeof CreateIntegrationIntegrationsEnabled
>;

export type DeleteEvent = {
  /**
   * If always, the integration will subscribe to delete events.
   */
  enabled?: CreateIntegrationIntegrationsEnabled | undefined;
};

/**
 * If always, the integration will subscribe to association change events.
 */
export const CreateIntegrationIntegrationsRequestEnabled = {
  Always: "always",
} as const;
/**
 * If always, the integration will subscribe to association change events.
 */
export type CreateIntegrationIntegrationsRequestEnabled = ClosedEnum<
  typeof CreateIntegrationIntegrationsRequestEnabled
>;

export type AssociationChangeEvent = {
  /**
   * If always, the integration will subscribe to association change events.
   */
  enabled?: CreateIntegrationIntegrationsRequestEnabled | undefined;
  /**
   * If true, the integration will include full records in the event payload.
   */
  includeFullRecords?: boolean | undefined;
};

export type IntegrationSubscribeObject = {
  objectName: string;
  destination: string;
  /**
   * If true, the integration will inherit the fields and mapping from the read object.
   */
  inheritFieldsAndMapping?: boolean | undefined;
  createEvent?: CreateEvent | undefined;
  updateEvent?: UpdateEvent | undefined;
  deleteEvent?: DeleteEvent | undefined;
  associationChangeEvent?: AssociationChangeEvent | undefined;
  otherEvents?: Array<string> | undefined;
};

export type SubscribeIntegration = {
  objects?: Array<IntegrationSubscribeObject> | undefined;
};

export type Integration = {
  name: string;
  displayName?: string | undefined;
  provider: string;
  read?: ReadIntegration | undefined;
  write?: WriteIntegration | undefined;
  proxy?: ProxyIntegration | undefined;
  subscribe?: SubscribeIntegration | undefined;
};

export type LatestRevision = {
  /**
   * The spec version string.
   */
  specVersion: string;
  content: Integration;
};

export type CreateIntegrationRequestBody = {
  /**
   * The integration name.
   */
  name: string;
  /**
   * The provider name (e.g. "salesforce", "hubspot")
   */
  provider: string;
  latestRevision: LatestRevision;
};

export type CreateIntegrationRequest = {
  /**
   * The Ampersand project ID or project name.
   */
  projectIdOrName: string;
  requestBody: CreateIntegrationRequestBody;
};

/**
 * A Problem Details object (RFC 9457).
 *
 * @remarks
 *
 * Additional properties specific to the problem type may be present.
 */
export type CreateIntegrationAPIProblem = {
  /**
   * An absolute URI that identifies the problem type
   */
  type?: string | undefined;
  /**
   * An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
   */
  href?: string | undefined;
  /**
   * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
   */
  title?: string | undefined;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   */
  status?: number | undefined;
  /**
   * A human-readable explanation specific to this occurrence of the problem
   */
  detail?: string | undefined;
  /**
   * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   */
  instance?: string | undefined;
  /**
   * The subsystem that generated the problem
   */
  subsystem?: string | undefined;
  /**
   * The time the problem occurred, formatted as RFC-3339
   */
  time?: Date | undefined;
  /**
   * A unique identifier for the request, useful for debugging
   */
  requestId?: string | undefined;
  /**
   * A list of problems that caused this problem. This can be used to represent multiple
   *
   * @remarks
   * root causes. There is no guaranteed ordering of the causes.
   */
  causes?: Array<string> | undefined;
  /**
   * A brief description of how to resolve the problem
   */
  remedy?: string | undefined;
  /**
   * An email address to contact for support
   */
  supportEmail?: string | undefined;
  /**
   * A phone number to contact for support
   */
  supportPhone?: string | undefined;
  /**
   * A URL to contact for support
   */
  supportUrl?: string | undefined;
  /**
   * Whether the request can be retried
   */
  retryable?: boolean | undefined;
  /**
   * A timestamp after which the request can be retried, formatted as RFC-3339
   */
  retryAfter?: Date | undefined;
  /**
   * Additional context for the problem
   */
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const IntegrationFieldMapping$inboundSchema: z.ZodType<
  IntegrationFieldMapping,
  z.ZodTypeDef,
  unknown
> = z.object({
  mapToName: z.string(),
  mapToDisplayName: z.string().optional(),
  default: z.string().optional(),
  prompt: z.string().optional(),
});

/** @internal */
export type IntegrationFieldMapping$Outbound = {
  mapToName: string;
  mapToDisplayName?: string | undefined;
  default?: string | undefined;
  prompt?: string | undefined;
};

/** @internal */
export const IntegrationFieldMapping$outboundSchema: z.ZodType<
  IntegrationFieldMapping$Outbound,
  z.ZodTypeDef,
  IntegrationFieldMapping
> = z.object({
  mapToName: z.string(),
  mapToDisplayName: z.string().optional(),
  default: z.string().optional(),
  prompt: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationFieldMapping$ {
  /** @deprecated use `IntegrationFieldMapping$inboundSchema` instead. */
  export const inboundSchema = IntegrationFieldMapping$inboundSchema;
  /** @deprecated use `IntegrationFieldMapping$outboundSchema` instead. */
  export const outboundSchema = IntegrationFieldMapping$outboundSchema;
  /** @deprecated use `IntegrationFieldMapping$Outbound` instead. */
  export type Outbound = IntegrationFieldMapping$Outbound;
}

export function integrationFieldMappingToJSON(
  integrationFieldMapping: IntegrationFieldMapping,
): string {
  return JSON.stringify(
    IntegrationFieldMapping$outboundSchema.parse(integrationFieldMapping),
  );
}

export function integrationFieldMappingFromJSON(
  jsonString: string,
): SafeParseResult<IntegrationFieldMapping, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationFieldMapping$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationFieldMapping' from JSON`,
  );
}

/** @internal */
export const IntegrationFieldExistent$inboundSchema: z.ZodType<
  IntegrationFieldExistent,
  z.ZodTypeDef,
  unknown
> = z.object({
  fieldName: z.string(),
  mapToName: z.string().optional(),
  mapToDisplayName: z.string().optional(),
});

/** @internal */
export type IntegrationFieldExistent$Outbound = {
  fieldName: string;
  mapToName?: string | undefined;
  mapToDisplayName?: string | undefined;
};

/** @internal */
export const IntegrationFieldExistent$outboundSchema: z.ZodType<
  IntegrationFieldExistent$Outbound,
  z.ZodTypeDef,
  IntegrationFieldExistent
> = z.object({
  fieldName: z.string(),
  mapToName: z.string().optional(),
  mapToDisplayName: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationFieldExistent$ {
  /** @deprecated use `IntegrationFieldExistent$inboundSchema` instead. */
  export const inboundSchema = IntegrationFieldExistent$inboundSchema;
  /** @deprecated use `IntegrationFieldExistent$outboundSchema` instead. */
  export const outboundSchema = IntegrationFieldExistent$outboundSchema;
  /** @deprecated use `IntegrationFieldExistent$Outbound` instead. */
  export type Outbound = IntegrationFieldExistent$Outbound;
}

export function integrationFieldExistentToJSON(
  integrationFieldExistent: IntegrationFieldExistent,
): string {
  return JSON.stringify(
    IntegrationFieldExistent$outboundSchema.parse(integrationFieldExistent),
  );
}

export function integrationFieldExistentFromJSON(
  jsonString: string,
): SafeParseResult<IntegrationFieldExistent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationFieldExistent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationFieldExistent' from JSON`,
  );
}

/** @internal */
export const IntegrationField$inboundSchema: z.ZodType<
  IntegrationField,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => IntegrationFieldExistent$inboundSchema),
  z.lazy(() => IntegrationFieldMapping$inboundSchema),
]);

/** @internal */
export type IntegrationField$Outbound =
  | IntegrationFieldExistent$Outbound
  | IntegrationFieldMapping$Outbound;

/** @internal */
export const IntegrationField$outboundSchema: z.ZodType<
  IntegrationField$Outbound,
  z.ZodTypeDef,
  IntegrationField
> = z.union([
  z.lazy(() => IntegrationFieldExistent$outboundSchema),
  z.lazy(() => IntegrationFieldMapping$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationField$ {
  /** @deprecated use `IntegrationField$inboundSchema` instead. */
  export const inboundSchema = IntegrationField$inboundSchema;
  /** @deprecated use `IntegrationField$outboundSchema` instead. */
  export const outboundSchema = IntegrationField$outboundSchema;
  /** @deprecated use `IntegrationField$Outbound` instead. */
  export type Outbound = IntegrationField$Outbound;
}

export function integrationFieldToJSON(
  integrationField: IntegrationField,
): string {
  return JSON.stringify(
    IntegrationField$outboundSchema.parse(integrationField),
  );
}

export function integrationFieldFromJSON(
  jsonString: string,
): SafeParseResult<IntegrationField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationField' from JSON`,
  );
}

/** @internal */
export const IntegrationFieldIntegrationFieldMapping$inboundSchema: z.ZodType<
  IntegrationFieldIntegrationFieldMapping,
  z.ZodTypeDef,
  unknown
> = z.object({
  mapToName: z.string(),
  mapToDisplayName: z.string().optional(),
  default: z.string().optional(),
  prompt: z.string().optional(),
});

/** @internal */
export type IntegrationFieldIntegrationFieldMapping$Outbound = {
  mapToName: string;
  mapToDisplayName?: string | undefined;
  default?: string | undefined;
  prompt?: string | undefined;
};

/** @internal */
export const IntegrationFieldIntegrationFieldMapping$outboundSchema: z.ZodType<
  IntegrationFieldIntegrationFieldMapping$Outbound,
  z.ZodTypeDef,
  IntegrationFieldIntegrationFieldMapping
> = z.object({
  mapToName: z.string(),
  mapToDisplayName: z.string().optional(),
  default: z.string().optional(),
  prompt: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationFieldIntegrationFieldMapping$ {
  /** @deprecated use `IntegrationFieldIntegrationFieldMapping$inboundSchema` instead. */
  export const inboundSchema =
    IntegrationFieldIntegrationFieldMapping$inboundSchema;
  /** @deprecated use `IntegrationFieldIntegrationFieldMapping$outboundSchema` instead. */
  export const outboundSchema =
    IntegrationFieldIntegrationFieldMapping$outboundSchema;
  /** @deprecated use `IntegrationFieldIntegrationFieldMapping$Outbound` instead. */
  export type Outbound = IntegrationFieldIntegrationFieldMapping$Outbound;
}

export function integrationFieldIntegrationFieldMappingToJSON(
  integrationFieldIntegrationFieldMapping:
    IntegrationFieldIntegrationFieldMapping,
): string {
  return JSON.stringify(
    IntegrationFieldIntegrationFieldMapping$outboundSchema.parse(
      integrationFieldIntegrationFieldMapping,
    ),
  );
}

export function integrationFieldIntegrationFieldMappingFromJSON(
  jsonString: string,
): SafeParseResult<
  IntegrationFieldIntegrationFieldMapping,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      IntegrationFieldIntegrationFieldMapping$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'IntegrationFieldIntegrationFieldMapping' from JSON`,
  );
}

/** @internal */
export const IntegrationFieldIntegrationFieldExistent$inboundSchema: z.ZodType<
  IntegrationFieldIntegrationFieldExistent,
  z.ZodTypeDef,
  unknown
> = z.object({
  fieldName: z.string(),
  mapToName: z.string().optional(),
  mapToDisplayName: z.string().optional(),
});

/** @internal */
export type IntegrationFieldIntegrationFieldExistent$Outbound = {
  fieldName: string;
  mapToName?: string | undefined;
  mapToDisplayName?: string | undefined;
};

/** @internal */
export const IntegrationFieldIntegrationFieldExistent$outboundSchema: z.ZodType<
  IntegrationFieldIntegrationFieldExistent$Outbound,
  z.ZodTypeDef,
  IntegrationFieldIntegrationFieldExistent
> = z.object({
  fieldName: z.string(),
  mapToName: z.string().optional(),
  mapToDisplayName: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationFieldIntegrationFieldExistent$ {
  /** @deprecated use `IntegrationFieldIntegrationFieldExistent$inboundSchema` instead. */
  export const inboundSchema =
    IntegrationFieldIntegrationFieldExistent$inboundSchema;
  /** @deprecated use `IntegrationFieldIntegrationFieldExistent$outboundSchema` instead. */
  export const outboundSchema =
    IntegrationFieldIntegrationFieldExistent$outboundSchema;
  /** @deprecated use `IntegrationFieldIntegrationFieldExistent$Outbound` instead. */
  export type Outbound = IntegrationFieldIntegrationFieldExistent$Outbound;
}

export function integrationFieldIntegrationFieldExistentToJSON(
  integrationFieldIntegrationFieldExistent:
    IntegrationFieldIntegrationFieldExistent,
): string {
  return JSON.stringify(
    IntegrationFieldIntegrationFieldExistent$outboundSchema.parse(
      integrationFieldIntegrationFieldExistent,
    ),
  );
}

export function integrationFieldIntegrationFieldExistentFromJSON(
  jsonString: string,
): SafeParseResult<
  IntegrationFieldIntegrationFieldExistent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      IntegrationFieldIntegrationFieldExistent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'IntegrationFieldIntegrationFieldExistent' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationIntegrationField$inboundSchema: z.ZodType<
  CreateIntegrationIntegrationField,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => IntegrationFieldIntegrationFieldExistent$inboundSchema),
  z.lazy(() => IntegrationFieldIntegrationFieldMapping$inboundSchema),
]);

/** @internal */
export type CreateIntegrationIntegrationField$Outbound =
  | IntegrationFieldIntegrationFieldExistent$Outbound
  | IntegrationFieldIntegrationFieldMapping$Outbound;

/** @internal */
export const CreateIntegrationIntegrationField$outboundSchema: z.ZodType<
  CreateIntegrationIntegrationField$Outbound,
  z.ZodTypeDef,
  CreateIntegrationIntegrationField
> = z.union([
  z.lazy(() => IntegrationFieldIntegrationFieldExistent$outboundSchema),
  z.lazy(() => IntegrationFieldIntegrationFieldMapping$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationIntegrationField$ {
  /** @deprecated use `CreateIntegrationIntegrationField$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationIntegrationField$inboundSchema;
  /** @deprecated use `CreateIntegrationIntegrationField$outboundSchema` instead. */
  export const outboundSchema =
    CreateIntegrationIntegrationField$outboundSchema;
  /** @deprecated use `CreateIntegrationIntegrationField$Outbound` instead. */
  export type Outbound = CreateIntegrationIntegrationField$Outbound;
}

export function createIntegrationIntegrationFieldToJSON(
  createIntegrationIntegrationField: CreateIntegrationIntegrationField,
): string {
  return JSON.stringify(
    CreateIntegrationIntegrationField$outboundSchema.parse(
      createIntegrationIntegrationField,
    ),
  );
}

export function createIntegrationIntegrationFieldFromJSON(
  jsonString: string,
): SafeParseResult<CreateIntegrationIntegrationField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateIntegrationIntegrationField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateIntegrationIntegrationField' from JSON`,
  );
}

/** @internal */
export const OptionalFieldsAutoOption$inboundSchema: z.ZodNativeEnum<
  typeof OptionalFieldsAutoOption
> = z.nativeEnum(OptionalFieldsAutoOption);

/** @internal */
export const OptionalFieldsAutoOption$outboundSchema: z.ZodNativeEnum<
  typeof OptionalFieldsAutoOption
> = OptionalFieldsAutoOption$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OptionalFieldsAutoOption$ {
  /** @deprecated use `OptionalFieldsAutoOption$inboundSchema` instead. */
  export const inboundSchema = OptionalFieldsAutoOption$inboundSchema;
  /** @deprecated use `OptionalFieldsAutoOption$outboundSchema` instead. */
  export const outboundSchema = OptionalFieldsAutoOption$outboundSchema;
}

/** @internal */
export const DefaultPeriod$inboundSchema: z.ZodType<
  DefaultPeriod,
  z.ZodTypeDef,
  unknown
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/** @internal */
export type DefaultPeriod$Outbound = {
  days?: number | undefined;
  fullHistory?: boolean | undefined;
};

/** @internal */
export const DefaultPeriod$outboundSchema: z.ZodType<
  DefaultPeriod$Outbound,
  z.ZodTypeDef,
  DefaultPeriod
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultPeriod$ {
  /** @deprecated use `DefaultPeriod$inboundSchema` instead. */
  export const inboundSchema = DefaultPeriod$inboundSchema;
  /** @deprecated use `DefaultPeriod$outboundSchema` instead. */
  export const outboundSchema = DefaultPeriod$outboundSchema;
  /** @deprecated use `DefaultPeriod$Outbound` instead. */
  export type Outbound = DefaultPeriod$Outbound;
}

export function defaultPeriodToJSON(defaultPeriod: DefaultPeriod): string {
  return JSON.stringify(DefaultPeriod$outboundSchema.parse(defaultPeriod));
}

export function defaultPeriodFromJSON(
  jsonString: string,
): SafeParseResult<DefaultPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultPeriod' from JSON`,
  );
}

/** @internal */
export const Backfill$inboundSchema: z.ZodType<
  Backfill,
  z.ZodTypeDef,
  unknown
> = z.object({
  defaultPeriod: z.lazy(() => DefaultPeriod$inboundSchema),
});

/** @internal */
export type Backfill$Outbound = {
  defaultPeriod: DefaultPeriod$Outbound;
};

/** @internal */
export const Backfill$outboundSchema: z.ZodType<
  Backfill$Outbound,
  z.ZodTypeDef,
  Backfill
> = z.object({
  defaultPeriod: z.lazy(() => DefaultPeriod$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Backfill$ {
  /** @deprecated use `Backfill$inboundSchema` instead. */
  export const inboundSchema = Backfill$inboundSchema;
  /** @deprecated use `Backfill$outboundSchema` instead. */
  export const outboundSchema = Backfill$outboundSchema;
  /** @deprecated use `Backfill$Outbound` instead. */
  export type Outbound = Backfill$Outbound;
}

export function backfillToJSON(backfill: Backfill): string {
  return JSON.stringify(Backfill$outboundSchema.parse(backfill));
}

export function backfillFromJSON(
  jsonString: string,
): SafeParseResult<Backfill, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Backfill$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Backfill' from JSON`,
  );
}

/** @internal */
export const Mode$inboundSchema: z.ZodNativeEnum<typeof Mode> = z.nativeEnum(
  Mode,
);

/** @internal */
export const Mode$outboundSchema: z.ZodNativeEnum<typeof Mode> =
  Mode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Mode$ {
  /** @deprecated use `Mode$inboundSchema` instead. */
  export const inboundSchema = Mode$inboundSchema;
  /** @deprecated use `Mode$outboundSchema` instead. */
  export const outboundSchema = Mode$outboundSchema;
}

/** @internal */
export const Delivery$inboundSchema: z.ZodType<
  Delivery,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: Mode$inboundSchema.default("auto"),
  pageSize: z.number().int().optional(),
});

/** @internal */
export type Delivery$Outbound = {
  mode: string;
  pageSize?: number | undefined;
};

/** @internal */
export const Delivery$outboundSchema: z.ZodType<
  Delivery$Outbound,
  z.ZodTypeDef,
  Delivery
> = z.object({
  mode: Mode$outboundSchema.default("auto"),
  pageSize: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Delivery$ {
  /** @deprecated use `Delivery$inboundSchema` instead. */
  export const inboundSchema = Delivery$inboundSchema;
  /** @deprecated use `Delivery$outboundSchema` instead. */
  export const outboundSchema = Delivery$outboundSchema;
  /** @deprecated use `Delivery$Outbound` instead. */
  export type Outbound = Delivery$Outbound;
}

export function deliveryToJSON(delivery: Delivery): string {
  return JSON.stringify(Delivery$outboundSchema.parse(delivery));
}

export function deliveryFromJSON(
  jsonString: string,
): SafeParseResult<Delivery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Delivery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Delivery' from JSON`,
  );
}

/** @internal */
export const IntegrationObject$inboundSchema: z.ZodType<
  IntegrationObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string(),
  destination: z.string(),
  schedule: z.string(),
  mapToName: z.string().optional(),
  mapToDisplayName: z.string().optional(),
  requiredFields: z.array(
    z.union([
      z.lazy(() => IntegrationFieldExistent$inboundSchema),
      z.lazy(() => IntegrationFieldMapping$inboundSchema),
    ]),
  ).optional(),
  optionalFields: z.array(
    z.union([
      z.lazy(() => IntegrationFieldIntegrationFieldExistent$inboundSchema),
      z.lazy(() => IntegrationFieldIntegrationFieldMapping$inboundSchema),
    ]),
  ).optional(),
  optionalFieldsAuto: OptionalFieldsAutoOption$inboundSchema.optional(),
  backfill: z.lazy(() => Backfill$inboundSchema).optional(),
  delivery: z.lazy(() => Delivery$inboundSchema).optional(),
});

/** @internal */
export type IntegrationObject$Outbound = {
  objectName: string;
  destination: string;
  schedule: string;
  mapToName?: string | undefined;
  mapToDisplayName?: string | undefined;
  requiredFields?:
    | Array<
      IntegrationFieldExistent$Outbound | IntegrationFieldMapping$Outbound
    >
    | undefined;
  optionalFields?:
    | Array<
      | IntegrationFieldIntegrationFieldExistent$Outbound
      | IntegrationFieldIntegrationFieldMapping$Outbound
    >
    | undefined;
  optionalFieldsAuto?: string | undefined;
  backfill?: Backfill$Outbound | undefined;
  delivery?: Delivery$Outbound | undefined;
};

/** @internal */
export const IntegrationObject$outboundSchema: z.ZodType<
  IntegrationObject$Outbound,
  z.ZodTypeDef,
  IntegrationObject
> = z.object({
  objectName: z.string(),
  destination: z.string(),
  schedule: z.string(),
  mapToName: z.string().optional(),
  mapToDisplayName: z.string().optional(),
  requiredFields: z.array(
    z.union([
      z.lazy(() => IntegrationFieldExistent$outboundSchema),
      z.lazy(() => IntegrationFieldMapping$outboundSchema),
    ]),
  ).optional(),
  optionalFields: z.array(
    z.union([
      z.lazy(() => IntegrationFieldIntegrationFieldExistent$outboundSchema),
      z.lazy(() => IntegrationFieldIntegrationFieldMapping$outboundSchema),
    ]),
  ).optional(),
  optionalFieldsAuto: OptionalFieldsAutoOption$outboundSchema.optional(),
  backfill: z.lazy(() => Backfill$outboundSchema).optional(),
  delivery: z.lazy(() => Delivery$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationObject$ {
  /** @deprecated use `IntegrationObject$inboundSchema` instead. */
  export const inboundSchema = IntegrationObject$inboundSchema;
  /** @deprecated use `IntegrationObject$outboundSchema` instead. */
  export const outboundSchema = IntegrationObject$outboundSchema;
  /** @deprecated use `IntegrationObject$Outbound` instead. */
  export type Outbound = IntegrationObject$Outbound;
}

export function integrationObjectToJSON(
  integrationObject: IntegrationObject,
): string {
  return JSON.stringify(
    IntegrationObject$outboundSchema.parse(integrationObject),
  );
}

export function integrationObjectFromJSON(
  jsonString: string,
): SafeParseResult<IntegrationObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationObject' from JSON`,
  );
}

/** @internal */
export const ReadIntegration$inboundSchema: z.ZodType<
  ReadIntegration,
  z.ZodTypeDef,
  unknown
> = z.object({
  objects: z.array(z.lazy(() => IntegrationObject$inboundSchema)).optional(),
});

/** @internal */
export type ReadIntegration$Outbound = {
  objects?: Array<IntegrationObject$Outbound> | undefined;
};

/** @internal */
export const ReadIntegration$outboundSchema: z.ZodType<
  ReadIntegration$Outbound,
  z.ZodTypeDef,
  ReadIntegration
> = z.object({
  objects: z.array(z.lazy(() => IntegrationObject$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReadIntegration$ {
  /** @deprecated use `ReadIntegration$inboundSchema` instead. */
  export const inboundSchema = ReadIntegration$inboundSchema;
  /** @deprecated use `ReadIntegration$outboundSchema` instead. */
  export const outboundSchema = ReadIntegration$outboundSchema;
  /** @deprecated use `ReadIntegration$Outbound` instead. */
  export type Outbound = ReadIntegration$Outbound;
}

export function readIntegrationToJSON(
  readIntegration: ReadIntegration,
): string {
  return JSON.stringify(ReadIntegration$outboundSchema.parse(readIntegration));
}

export function readIntegrationFromJSON(
  jsonString: string,
): SafeParseResult<ReadIntegration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReadIntegration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReadIntegration' from JSON`,
  );
}

/** @internal */
export const ValueDefaults$inboundSchema: z.ZodType<
  ValueDefaults,
  z.ZodTypeDef,
  unknown
> = z.object({
  allowAnyFields: z.boolean().optional(),
});

/** @internal */
export type ValueDefaults$Outbound = {
  allowAnyFields?: boolean | undefined;
};

/** @internal */
export const ValueDefaults$outboundSchema: z.ZodType<
  ValueDefaults$Outbound,
  z.ZodTypeDef,
  ValueDefaults
> = z.object({
  allowAnyFields: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValueDefaults$ {
  /** @deprecated use `ValueDefaults$inboundSchema` instead. */
  export const inboundSchema = ValueDefaults$inboundSchema;
  /** @deprecated use `ValueDefaults$outboundSchema` instead. */
  export const outboundSchema = ValueDefaults$outboundSchema;
  /** @deprecated use `ValueDefaults$Outbound` instead. */
  export type Outbound = ValueDefaults$Outbound;
}

export function valueDefaultsToJSON(valueDefaults: ValueDefaults): string {
  return JSON.stringify(ValueDefaults$outboundSchema.parse(valueDefaults));
}

export function valueDefaultsFromJSON(
  jsonString: string,
): SafeParseResult<ValueDefaults, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValueDefaults$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValueDefaults' from JSON`,
  );
}

/** @internal */
export const IntegrationWriteObject$inboundSchema: z.ZodType<
  IntegrationWriteObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string(),
  inheritMapping: z.boolean().optional(),
  valueDefaults: z.lazy(() => ValueDefaults$inboundSchema).optional(),
});

/** @internal */
export type IntegrationWriteObject$Outbound = {
  objectName: string;
  inheritMapping?: boolean | undefined;
  valueDefaults?: ValueDefaults$Outbound | undefined;
};

/** @internal */
export const IntegrationWriteObject$outboundSchema: z.ZodType<
  IntegrationWriteObject$Outbound,
  z.ZodTypeDef,
  IntegrationWriteObject
> = z.object({
  objectName: z.string(),
  inheritMapping: z.boolean().optional(),
  valueDefaults: z.lazy(() => ValueDefaults$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationWriteObject$ {
  /** @deprecated use `IntegrationWriteObject$inboundSchema` instead. */
  export const inboundSchema = IntegrationWriteObject$inboundSchema;
  /** @deprecated use `IntegrationWriteObject$outboundSchema` instead. */
  export const outboundSchema = IntegrationWriteObject$outboundSchema;
  /** @deprecated use `IntegrationWriteObject$Outbound` instead. */
  export type Outbound = IntegrationWriteObject$Outbound;
}

export function integrationWriteObjectToJSON(
  integrationWriteObject: IntegrationWriteObject,
): string {
  return JSON.stringify(
    IntegrationWriteObject$outboundSchema.parse(integrationWriteObject),
  );
}

export function integrationWriteObjectFromJSON(
  jsonString: string,
): SafeParseResult<IntegrationWriteObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationWriteObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationWriteObject' from JSON`,
  );
}

/** @internal */
export const WriteIntegration$inboundSchema: z.ZodType<
  WriteIntegration,
  z.ZodTypeDef,
  unknown
> = z.object({
  objects: z.array(z.lazy(() => IntegrationWriteObject$inboundSchema))
    .optional(),
});

/** @internal */
export type WriteIntegration$Outbound = {
  objects?: Array<IntegrationWriteObject$Outbound> | undefined;
};

/** @internal */
export const WriteIntegration$outboundSchema: z.ZodType<
  WriteIntegration$Outbound,
  z.ZodTypeDef,
  WriteIntegration
> = z.object({
  objects: z.array(z.lazy(() => IntegrationWriteObject$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WriteIntegration$ {
  /** @deprecated use `WriteIntegration$inboundSchema` instead. */
  export const inboundSchema = WriteIntegration$inboundSchema;
  /** @deprecated use `WriteIntegration$outboundSchema` instead. */
  export const outboundSchema = WriteIntegration$outboundSchema;
  /** @deprecated use `WriteIntegration$Outbound` instead. */
  export type Outbound = WriteIntegration$Outbound;
}

export function writeIntegrationToJSON(
  writeIntegration: WriteIntegration,
): string {
  return JSON.stringify(
    WriteIntegration$outboundSchema.parse(writeIntegration),
  );
}

export function writeIntegrationFromJSON(
  jsonString: string,
): SafeParseResult<WriteIntegration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WriteIntegration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WriteIntegration' from JSON`,
  );
}

/** @internal */
export const ProxyIntegration$inboundSchema: z.ZodType<
  ProxyIntegration,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});

/** @internal */
export type ProxyIntegration$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const ProxyIntegration$outboundSchema: z.ZodType<
  ProxyIntegration$Outbound,
  z.ZodTypeDef,
  ProxyIntegration
> = z.object({
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProxyIntegration$ {
  /** @deprecated use `ProxyIntegration$inboundSchema` instead. */
  export const inboundSchema = ProxyIntegration$inboundSchema;
  /** @deprecated use `ProxyIntegration$outboundSchema` instead. */
  export const outboundSchema = ProxyIntegration$outboundSchema;
  /** @deprecated use `ProxyIntegration$Outbound` instead. */
  export type Outbound = ProxyIntegration$Outbound;
}

export function proxyIntegrationToJSON(
  proxyIntegration: ProxyIntegration,
): string {
  return JSON.stringify(
    ProxyIntegration$outboundSchema.parse(proxyIntegration),
  );
}

export function proxyIntegrationFromJSON(
  jsonString: string,
): SafeParseResult<ProxyIntegration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProxyIntegration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProxyIntegration' from JSON`,
  );
}

/** @internal */
export const Enabled$inboundSchema: z.ZodNativeEnum<typeof Enabled> = z
  .nativeEnum(Enabled);

/** @internal */
export const Enabled$outboundSchema: z.ZodNativeEnum<typeof Enabled> =
  Enabled$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Enabled$ {
  /** @deprecated use `Enabled$inboundSchema` instead. */
  export const inboundSchema = Enabled$inboundSchema;
  /** @deprecated use `Enabled$outboundSchema` instead. */
  export const outboundSchema = Enabled$outboundSchema;
}

/** @internal */
export const CreateEvent$inboundSchema: z.ZodType<
  CreateEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: Enabled$inboundSchema.optional(),
});

/** @internal */
export type CreateEvent$Outbound = {
  enabled?: string | undefined;
};

/** @internal */
export const CreateEvent$outboundSchema: z.ZodType<
  CreateEvent$Outbound,
  z.ZodTypeDef,
  CreateEvent
> = z.object({
  enabled: Enabled$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateEvent$ {
  /** @deprecated use `CreateEvent$inboundSchema` instead. */
  export const inboundSchema = CreateEvent$inboundSchema;
  /** @deprecated use `CreateEvent$outboundSchema` instead. */
  export const outboundSchema = CreateEvent$outboundSchema;
  /** @deprecated use `CreateEvent$Outbound` instead. */
  export type Outbound = CreateEvent$Outbound;
}

export function createEventToJSON(createEvent: CreateEvent): string {
  return JSON.stringify(CreateEvent$outboundSchema.parse(createEvent));
}

export function createEventFromJSON(
  jsonString: string,
): SafeParseResult<CreateEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEvent' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationEnabled$inboundSchema: z.ZodNativeEnum<
  typeof CreateIntegrationEnabled
> = z.nativeEnum(CreateIntegrationEnabled);

/** @internal */
export const CreateIntegrationEnabled$outboundSchema: z.ZodNativeEnum<
  typeof CreateIntegrationEnabled
> = CreateIntegrationEnabled$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationEnabled$ {
  /** @deprecated use `CreateIntegrationEnabled$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationEnabled$inboundSchema;
  /** @deprecated use `CreateIntegrationEnabled$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationEnabled$outboundSchema;
}

/** @internal */
export const WatchFieldsAuto$inboundSchema: z.ZodNativeEnum<
  typeof WatchFieldsAuto
> = z.nativeEnum(WatchFieldsAuto);

/** @internal */
export const WatchFieldsAuto$outboundSchema: z.ZodNativeEnum<
  typeof WatchFieldsAuto
> = WatchFieldsAuto$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WatchFieldsAuto$ {
  /** @deprecated use `WatchFieldsAuto$inboundSchema` instead. */
  export const inboundSchema = WatchFieldsAuto$inboundSchema;
  /** @deprecated use `WatchFieldsAuto$outboundSchema` instead. */
  export const outboundSchema = WatchFieldsAuto$outboundSchema;
}

/** @internal */
export const UpdateEvent$inboundSchema: z.ZodType<
  UpdateEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: CreateIntegrationEnabled$inboundSchema.optional(),
  watchFieldsAuto: WatchFieldsAuto$inboundSchema.optional(),
  requiredWatchFields: z.array(z.string()).optional(),
});

/** @internal */
export type UpdateEvent$Outbound = {
  enabled?: string | undefined;
  watchFieldsAuto?: string | undefined;
  requiredWatchFields?: Array<string> | undefined;
};

/** @internal */
export const UpdateEvent$outboundSchema: z.ZodType<
  UpdateEvent$Outbound,
  z.ZodTypeDef,
  UpdateEvent
> = z.object({
  enabled: CreateIntegrationEnabled$outboundSchema.optional(),
  watchFieldsAuto: WatchFieldsAuto$outboundSchema.optional(),
  requiredWatchFields: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateEvent$ {
  /** @deprecated use `UpdateEvent$inboundSchema` instead. */
  export const inboundSchema = UpdateEvent$inboundSchema;
  /** @deprecated use `UpdateEvent$outboundSchema` instead. */
  export const outboundSchema = UpdateEvent$outboundSchema;
  /** @deprecated use `UpdateEvent$Outbound` instead. */
  export type Outbound = UpdateEvent$Outbound;
}

export function updateEventToJSON(updateEvent: UpdateEvent): string {
  return JSON.stringify(UpdateEvent$outboundSchema.parse(updateEvent));
}

export function updateEventFromJSON(
  jsonString: string,
): SafeParseResult<UpdateEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateEvent' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationIntegrationsEnabled$inboundSchema:
  z.ZodNativeEnum<typeof CreateIntegrationIntegrationsEnabled> = z.nativeEnum(
    CreateIntegrationIntegrationsEnabled,
  );

/** @internal */
export const CreateIntegrationIntegrationsEnabled$outboundSchema:
  z.ZodNativeEnum<typeof CreateIntegrationIntegrationsEnabled> =
    CreateIntegrationIntegrationsEnabled$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationIntegrationsEnabled$ {
  /** @deprecated use `CreateIntegrationIntegrationsEnabled$inboundSchema` instead. */
  export const inboundSchema =
    CreateIntegrationIntegrationsEnabled$inboundSchema;
  /** @deprecated use `CreateIntegrationIntegrationsEnabled$outboundSchema` instead. */
  export const outboundSchema =
    CreateIntegrationIntegrationsEnabled$outboundSchema;
}

/** @internal */
export const DeleteEvent$inboundSchema: z.ZodType<
  DeleteEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: CreateIntegrationIntegrationsEnabled$inboundSchema.optional(),
});

/** @internal */
export type DeleteEvent$Outbound = {
  enabled?: string | undefined;
};

/** @internal */
export const DeleteEvent$outboundSchema: z.ZodType<
  DeleteEvent$Outbound,
  z.ZodTypeDef,
  DeleteEvent
> = z.object({
  enabled: CreateIntegrationIntegrationsEnabled$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeleteEvent$ {
  /** @deprecated use `DeleteEvent$inboundSchema` instead. */
  export const inboundSchema = DeleteEvent$inboundSchema;
  /** @deprecated use `DeleteEvent$outboundSchema` instead. */
  export const outboundSchema = DeleteEvent$outboundSchema;
  /** @deprecated use `DeleteEvent$Outbound` instead. */
  export type Outbound = DeleteEvent$Outbound;
}

export function deleteEventToJSON(deleteEvent: DeleteEvent): string {
  return JSON.stringify(DeleteEvent$outboundSchema.parse(deleteEvent));
}

export function deleteEventFromJSON(
  jsonString: string,
): SafeParseResult<DeleteEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeleteEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeleteEvent' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationIntegrationsRequestEnabled$inboundSchema:
  z.ZodNativeEnum<typeof CreateIntegrationIntegrationsRequestEnabled> = z
    .nativeEnum(CreateIntegrationIntegrationsRequestEnabled);

/** @internal */
export const CreateIntegrationIntegrationsRequestEnabled$outboundSchema:
  z.ZodNativeEnum<typeof CreateIntegrationIntegrationsRequestEnabled> =
    CreateIntegrationIntegrationsRequestEnabled$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationIntegrationsRequestEnabled$ {
  /** @deprecated use `CreateIntegrationIntegrationsRequestEnabled$inboundSchema` instead. */
  export const inboundSchema =
    CreateIntegrationIntegrationsRequestEnabled$inboundSchema;
  /** @deprecated use `CreateIntegrationIntegrationsRequestEnabled$outboundSchema` instead. */
  export const outboundSchema =
    CreateIntegrationIntegrationsRequestEnabled$outboundSchema;
}

/** @internal */
export const AssociationChangeEvent$inboundSchema: z.ZodType<
  AssociationChangeEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: CreateIntegrationIntegrationsRequestEnabled$inboundSchema.optional(),
  includeFullRecords: z.boolean().optional(),
});

/** @internal */
export type AssociationChangeEvent$Outbound = {
  enabled?: string | undefined;
  includeFullRecords?: boolean | undefined;
};

/** @internal */
export const AssociationChangeEvent$outboundSchema: z.ZodType<
  AssociationChangeEvent$Outbound,
  z.ZodTypeDef,
  AssociationChangeEvent
> = z.object({
  enabled: CreateIntegrationIntegrationsRequestEnabled$outboundSchema
    .optional(),
  includeFullRecords: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssociationChangeEvent$ {
  /** @deprecated use `AssociationChangeEvent$inboundSchema` instead. */
  export const inboundSchema = AssociationChangeEvent$inboundSchema;
  /** @deprecated use `AssociationChangeEvent$outboundSchema` instead. */
  export const outboundSchema = AssociationChangeEvent$outboundSchema;
  /** @deprecated use `AssociationChangeEvent$Outbound` instead. */
  export type Outbound = AssociationChangeEvent$Outbound;
}

export function associationChangeEventToJSON(
  associationChangeEvent: AssociationChangeEvent,
): string {
  return JSON.stringify(
    AssociationChangeEvent$outboundSchema.parse(associationChangeEvent),
  );
}

export function associationChangeEventFromJSON(
  jsonString: string,
): SafeParseResult<AssociationChangeEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AssociationChangeEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AssociationChangeEvent' from JSON`,
  );
}

/** @internal */
export const IntegrationSubscribeObject$inboundSchema: z.ZodType<
  IntegrationSubscribeObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string(),
  destination: z.string(),
  inheritFieldsAndMapping: z.boolean().optional(),
  createEvent: z.lazy(() => CreateEvent$inboundSchema).optional(),
  updateEvent: z.lazy(() => UpdateEvent$inboundSchema).optional(),
  deleteEvent: z.lazy(() => DeleteEvent$inboundSchema).optional(),
  associationChangeEvent: z.lazy(() => AssociationChangeEvent$inboundSchema)
    .optional(),
  otherEvents: z.array(z.string()).optional(),
});

/** @internal */
export type IntegrationSubscribeObject$Outbound = {
  objectName: string;
  destination: string;
  inheritFieldsAndMapping?: boolean | undefined;
  createEvent?: CreateEvent$Outbound | undefined;
  updateEvent?: UpdateEvent$Outbound | undefined;
  deleteEvent?: DeleteEvent$Outbound | undefined;
  associationChangeEvent?: AssociationChangeEvent$Outbound | undefined;
  otherEvents?: Array<string> | undefined;
};

/** @internal */
export const IntegrationSubscribeObject$outboundSchema: z.ZodType<
  IntegrationSubscribeObject$Outbound,
  z.ZodTypeDef,
  IntegrationSubscribeObject
> = z.object({
  objectName: z.string(),
  destination: z.string(),
  inheritFieldsAndMapping: z.boolean().optional(),
  createEvent: z.lazy(() => CreateEvent$outboundSchema).optional(),
  updateEvent: z.lazy(() => UpdateEvent$outboundSchema).optional(),
  deleteEvent: z.lazy(() => DeleteEvent$outboundSchema).optional(),
  associationChangeEvent: z.lazy(() => AssociationChangeEvent$outboundSchema)
    .optional(),
  otherEvents: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationSubscribeObject$ {
  /** @deprecated use `IntegrationSubscribeObject$inboundSchema` instead. */
  export const inboundSchema = IntegrationSubscribeObject$inboundSchema;
  /** @deprecated use `IntegrationSubscribeObject$outboundSchema` instead. */
  export const outboundSchema = IntegrationSubscribeObject$outboundSchema;
  /** @deprecated use `IntegrationSubscribeObject$Outbound` instead. */
  export type Outbound = IntegrationSubscribeObject$Outbound;
}

export function integrationSubscribeObjectToJSON(
  integrationSubscribeObject: IntegrationSubscribeObject,
): string {
  return JSON.stringify(
    IntegrationSubscribeObject$outboundSchema.parse(integrationSubscribeObject),
  );
}

export function integrationSubscribeObjectFromJSON(
  jsonString: string,
): SafeParseResult<IntegrationSubscribeObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationSubscribeObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationSubscribeObject' from JSON`,
  );
}

/** @internal */
export const SubscribeIntegration$inboundSchema: z.ZodType<
  SubscribeIntegration,
  z.ZodTypeDef,
  unknown
> = z.object({
  objects: z.array(z.lazy(() => IntegrationSubscribeObject$inboundSchema))
    .optional(),
});

/** @internal */
export type SubscribeIntegration$Outbound = {
  objects?: Array<IntegrationSubscribeObject$Outbound> | undefined;
};

/** @internal */
export const SubscribeIntegration$outboundSchema: z.ZodType<
  SubscribeIntegration$Outbound,
  z.ZodTypeDef,
  SubscribeIntegration
> = z.object({
  objects: z.array(z.lazy(() => IntegrationSubscribeObject$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribeIntegration$ {
  /** @deprecated use `SubscribeIntegration$inboundSchema` instead. */
  export const inboundSchema = SubscribeIntegration$inboundSchema;
  /** @deprecated use `SubscribeIntegration$outboundSchema` instead. */
  export const outboundSchema = SubscribeIntegration$outboundSchema;
  /** @deprecated use `SubscribeIntegration$Outbound` instead. */
  export type Outbound = SubscribeIntegration$Outbound;
}

export function subscribeIntegrationToJSON(
  subscribeIntegration: SubscribeIntegration,
): string {
  return JSON.stringify(
    SubscribeIntegration$outboundSchema.parse(subscribeIntegration),
  );
}

export function subscribeIntegrationFromJSON(
  jsonString: string,
): SafeParseResult<SubscribeIntegration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribeIntegration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribeIntegration' from JSON`,
  );
}

/** @internal */
export const Integration$inboundSchema: z.ZodType<
  Integration,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  displayName: z.string().optional(),
  provider: z.string(),
  read: z.lazy(() => ReadIntegration$inboundSchema).optional(),
  write: z.lazy(() => WriteIntegration$inboundSchema).optional(),
  proxy: z.lazy(() => ProxyIntegration$inboundSchema).optional(),
  subscribe: z.lazy(() => SubscribeIntegration$inboundSchema).optional(),
});

/** @internal */
export type Integration$Outbound = {
  name: string;
  displayName?: string | undefined;
  provider: string;
  read?: ReadIntegration$Outbound | undefined;
  write?: WriteIntegration$Outbound | undefined;
  proxy?: ProxyIntegration$Outbound | undefined;
  subscribe?: SubscribeIntegration$Outbound | undefined;
};

/** @internal */
export const Integration$outboundSchema: z.ZodType<
  Integration$Outbound,
  z.ZodTypeDef,
  Integration
> = z.object({
  name: z.string(),
  displayName: z.string().optional(),
  provider: z.string(),
  read: z.lazy(() => ReadIntegration$outboundSchema).optional(),
  write: z.lazy(() => WriteIntegration$outboundSchema).optional(),
  proxy: z.lazy(() => ProxyIntegration$outboundSchema).optional(),
  subscribe: z.lazy(() => SubscribeIntegration$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Integration$ {
  /** @deprecated use `Integration$inboundSchema` instead. */
  export const inboundSchema = Integration$inboundSchema;
  /** @deprecated use `Integration$outboundSchema` instead. */
  export const outboundSchema = Integration$outboundSchema;
  /** @deprecated use `Integration$Outbound` instead. */
  export type Outbound = Integration$Outbound;
}

export function integrationToJSON(integration: Integration): string {
  return JSON.stringify(Integration$outboundSchema.parse(integration));
}

export function integrationFromJSON(
  jsonString: string,
): SafeParseResult<Integration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Integration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Integration' from JSON`,
  );
}

/** @internal */
export const LatestRevision$inboundSchema: z.ZodType<
  LatestRevision,
  z.ZodTypeDef,
  unknown
> = z.object({
  specVersion: z.string(),
  content: z.lazy(() => Integration$inboundSchema),
});

/** @internal */
export type LatestRevision$Outbound = {
  specVersion: string;
  content: Integration$Outbound;
};

/** @internal */
export const LatestRevision$outboundSchema: z.ZodType<
  LatestRevision$Outbound,
  z.ZodTypeDef,
  LatestRevision
> = z.object({
  specVersion: z.string(),
  content: z.lazy(() => Integration$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LatestRevision$ {
  /** @deprecated use `LatestRevision$inboundSchema` instead. */
  export const inboundSchema = LatestRevision$inboundSchema;
  /** @deprecated use `LatestRevision$outboundSchema` instead. */
  export const outboundSchema = LatestRevision$outboundSchema;
  /** @deprecated use `LatestRevision$Outbound` instead. */
  export type Outbound = LatestRevision$Outbound;
}

export function latestRevisionToJSON(latestRevision: LatestRevision): string {
  return JSON.stringify(LatestRevision$outboundSchema.parse(latestRevision));
}

export function latestRevisionFromJSON(
  jsonString: string,
): SafeParseResult<LatestRevision, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LatestRevision$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LatestRevision' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationRequestBody$inboundSchema: z.ZodType<
  CreateIntegrationRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  provider: z.string(),
  latestRevision: z.lazy(() => LatestRevision$inboundSchema),
});

/** @internal */
export type CreateIntegrationRequestBody$Outbound = {
  name: string;
  provider: string;
  latestRevision: LatestRevision$Outbound;
};

/** @internal */
export const CreateIntegrationRequestBody$outboundSchema: z.ZodType<
  CreateIntegrationRequestBody$Outbound,
  z.ZodTypeDef,
  CreateIntegrationRequestBody
> = z.object({
  name: z.string(),
  provider: z.string(),
  latestRevision: z.lazy(() => LatestRevision$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationRequestBody$ {
  /** @deprecated use `CreateIntegrationRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationRequestBody$inboundSchema;
  /** @deprecated use `CreateIntegrationRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationRequestBody$outboundSchema;
  /** @deprecated use `CreateIntegrationRequestBody$Outbound` instead. */
  export type Outbound = CreateIntegrationRequestBody$Outbound;
}

export function createIntegrationRequestBodyToJSON(
  createIntegrationRequestBody: CreateIntegrationRequestBody,
): string {
  return JSON.stringify(
    CreateIntegrationRequestBody$outboundSchema.parse(
      createIntegrationRequestBody,
    ),
  );
}

export function createIntegrationRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateIntegrationRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateIntegrationRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateIntegrationRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationRequest$inboundSchema: z.ZodType<
  CreateIntegrationRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIdOrName: z.string(),
  RequestBody: z.lazy(() => CreateIntegrationRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CreateIntegrationRequest$Outbound = {
  projectIdOrName: string;
  RequestBody: CreateIntegrationRequestBody$Outbound;
};

/** @internal */
export const CreateIntegrationRequest$outboundSchema: z.ZodType<
  CreateIntegrationRequest$Outbound,
  z.ZodTypeDef,
  CreateIntegrationRequest
> = z.object({
  projectIdOrName: z.string(),
  requestBody: z.lazy(() => CreateIntegrationRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationRequest$ {
  /** @deprecated use `CreateIntegrationRequest$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationRequest$inboundSchema;
  /** @deprecated use `CreateIntegrationRequest$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationRequest$outboundSchema;
  /** @deprecated use `CreateIntegrationRequest$Outbound` instead. */
  export type Outbound = CreateIntegrationRequest$Outbound;
}

export function createIntegrationRequestToJSON(
  createIntegrationRequest: CreateIntegrationRequest,
): string {
  return JSON.stringify(
    CreateIntegrationRequest$outboundSchema.parse(createIntegrationRequest),
  );
}

export function createIntegrationRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateIntegrationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateIntegrationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateIntegrationRequest' from JSON`,
  );
}

/** @internal */
export const CreateIntegrationAPIProblem$inboundSchema: z.ZodType<
  CreateIntegrationAPIProblem,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  context: z.record(z.any()).optional(),
});

/** @internal */
export type CreateIntegrationAPIProblem$Outbound = {
  type: string;
  href?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  subsystem?: string | undefined;
  time?: string | undefined;
  requestId?: string | undefined;
  causes?: Array<string> | undefined;
  remedy?: string | undefined;
  supportEmail?: string | undefined;
  supportPhone?: string | undefined;
  supportUrl?: string | undefined;
  retryable?: boolean | undefined;
  retryAfter?: string | undefined;
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const CreateIntegrationAPIProblem$outboundSchema: z.ZodType<
  CreateIntegrationAPIProblem$Outbound,
  z.ZodTypeDef,
  CreateIntegrationAPIProblem
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.date().transform(v => v.toISOString()).optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.date().transform(v => v.toISOString()).optional(),
  context: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationAPIProblem$ {
  /** @deprecated use `CreateIntegrationAPIProblem$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationAPIProblem$inboundSchema;
  /** @deprecated use `CreateIntegrationAPIProblem$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationAPIProblem$outboundSchema;
  /** @deprecated use `CreateIntegrationAPIProblem$Outbound` instead. */
  export type Outbound = CreateIntegrationAPIProblem$Outbound;
}

export function createIntegrationAPIProblemToJSON(
  createIntegrationAPIProblem: CreateIntegrationAPIProblem,
): string {
  return JSON.stringify(
    CreateIntegrationAPIProblem$outboundSchema.parse(
      createIntegrationAPIProblem,
    ),
  );
}

export function createIntegrationAPIProblemFromJSON(
  jsonString: string,
): SafeParseResult<CreateIntegrationAPIProblem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateIntegrationAPIProblem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateIntegrationAPIProblem' from JSON`,
  );
}
