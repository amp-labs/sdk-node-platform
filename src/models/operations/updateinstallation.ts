/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * If selectedFieldsAuto is set to all, all fields will be read.
 */
export const SelectedFieldsAutoConfig = {
  All: "all",
} as const;
/**
 * If selectedFieldsAuto is set to all, all fields will be read.
 */
export type SelectedFieldsAutoConfig = ClosedEnum<
  typeof SelectedFieldsAutoConfig
>;

export type DefaultPeriodConfig = {
  /**
   * Number of days in past to backfill from. 0 is no backfill. e.g) if 10, then backfill last 10 days of data. Required if fullHistory is not set.
   */
  days?: number | undefined;
  /**
   * If true, backfill all history. Required if days is not set.
   */
  fullHistory?: boolean | undefined;
};

export type BackfillConfig = {
  defaultPeriod: DefaultPeriodConfig;
};

export type BaseReadConfigObject = {
  /**
   * The name of the object to read from.
   */
  objectName?: string | undefined;
  /**
   * The schedule for reading the object, in cron syntax.
   */
  schedule?: string | undefined;
  /**
   * The name of the destination that the result should be sent to.
   */
  destination?: string | undefined;
  /**
   * This is a map of field names to booleans indicating whether they should be read. If a field is already included in `selectedFieldMappings`, it does not need to be included here.
   */
  selectedFields?: { [k: string]: boolean } | undefined;
  /**
   * This is a map of field names to their value mappings.
   */
  selectedValueMappings?: { [k: string]: { [k: string]: string } } | undefined;
  /**
   * This is a map of mapToNames to field names. (A mapTo name is the name the builder wants to map a field to when it lands in their destination.)
   */
  selectedFieldMappings?: { [k: string]: string } | undefined;
  /**
   * If selectedFieldsAuto is set to all, all fields will be read.
   */
  selectedFieldsAuto?: SelectedFieldsAutoConfig | undefined;
  backfill?: BackfillConfig | undefined;
};

export type BaseReadConfig = {
  /**
   * This is a map of object names to their configuration.
   */
  objects?: { [k: string]: BaseReadConfigObject } | undefined;
};

/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export const UpdateInstallationValueDefaultLegacyApplyOnUpdate = {
  Always: "always",
  Never: "never",
} as const;
/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export type UpdateInstallationValueDefaultLegacyApplyOnUpdate = ClosedEnum<
  typeof UpdateInstallationValueDefaultLegacyApplyOnUpdate
>;

export type ValueDefaultBoolean = {
  /**
   * The value to be used as a default.
   */
  value: boolean;
  /**
   * Whether the default value should be applied when updating a record.
   *
   * @remarks
   * If set to `always`, the default value will be applied when updating a record.
   * If set to `never`, the default value will not be applied when updating a record,
   * only when creating a record.
   * If unspecified, then `always` is assumed.
   */
  applyOnUpdate?: UpdateInstallationValueDefaultLegacyApplyOnUpdate | undefined;
};

/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export const ValueDefaultLegacyApplyOnUpdate = {
  Always: "always",
  Never: "never",
} as const;
/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export type ValueDefaultLegacyApplyOnUpdate = ClosedEnum<
  typeof ValueDefaultLegacyApplyOnUpdate
>;

export type ValueDefaultInteger = {
  /**
   * The value to be used as a default.
   */
  value: number;
  /**
   * Whether the default value should be applied when updating a record.
   *
   * @remarks
   * If set to `always`, the default value will be applied when updating a record.
   * If set to `never`, the default value will not be applied when updating a record,
   * only when creating a record.
   * If unspecified, then `always` is assumed.
   */
  applyOnUpdate?: ValueDefaultLegacyApplyOnUpdate | undefined;
};

/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export const ApplyOnUpdate = {
  Always: "always",
  Never: "never",
} as const;
/**
 * Whether the default value should be applied when updating a record.
 *
 * @remarks
 * If set to `always`, the default value will be applied when updating a record.
 * If set to `never`, the default value will not be applied when updating a record,
 * only when creating a record.
 * If unspecified, then `always` is assumed.
 */
export type ApplyOnUpdate = ClosedEnum<typeof ApplyOnUpdate>;

export type ValueDefaultString = {
  /**
   * The value to be used as a default.
   */
  value: string;
  /**
   * Whether the default value should be applied when updating a record.
   *
   * @remarks
   * If set to `always`, the default value will be applied when updating a record.
   * If set to `never`, the default value will not be applied when updating a record,
   * only when creating a record.
   * If unspecified, then `always` is assumed.
   */
  applyOnUpdate?: ApplyOnUpdate | undefined;
};

/**
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type ValueDefaultLegacy =
  | ValueDefaultString
  | ValueDefaultInteger
  | ValueDefaultBoolean;

/**
 * Only use one of stringValue, integerValue, booleanValue.
 */
export type DefaultValueForAField = {
  /**
   * The default string value to apply to a field
   */
  stringValue?: string | undefined;
  /**
   * The default integer value to apply to a field
   */
  integerValue?: number | undefined;
  /**
   * The default boolean value to apply to a field
   */
  booleanValue?: boolean | undefined;
};

/**
 * Whether the default value should be applied when creating a record.
 */
export const WriteOnCreate = {
  Always: "always",
  Never: "never",
} as const;
/**
 * Whether the default value should be applied when creating a record.
 */
export type WriteOnCreate = ClosedEnum<typeof WriteOnCreate>;

/**
 * Whether the default value should be applied when updating a record.
 */
export const WriteOnUpdate = {
  Always: "always",
  Never: "never",
} as const;
/**
 * Whether the default value should be applied when updating a record.
 */
export type WriteOnUpdate = ClosedEnum<typeof WriteOnUpdate>;

export type FieldSetting = {
  /**
   * Only use one of stringValue, integerValue, booleanValue.
   */
  default?: DefaultValueForAField | undefined;
  /**
   * Whether the default value should be applied when creating a record.
   */
  writeOnCreate?: WriteOnCreate | undefined;
  /**
   * Whether the default value should be applied when updating a record.
   */
  writeOnUpdate?: WriteOnUpdate | undefined;
};

export type BaseWriteConfigObject = {
  /**
   * The name of the object to write to.
   */
  objectName: string;
  /**
   * This is a map of field names to default values. These values will be used when writing to the object.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  selectedValueDefaults?: {
    [k: string]: ValueDefaultString | ValueDefaultInteger | ValueDefaultBoolean;
  } | undefined;
  /**
   * This is a map of field names to their settings.
   */
  selectedFieldSettings?: { [k: string]: FieldSetting } | undefined;
};

export type BaseWriteConfig = {
  /**
   * This is a map of object names to their configuration.
   */
  objects?: { [k: string]: BaseWriteConfigObject } | undefined;
};

export type UpdateInstallationBaseProxyConfig = {
  enabled?: boolean | undefined;
};

/**
 * The content of the config.
 */
export type UpdateInstallationConfigContent = {
  /**
   * The SaaS API that we are integrating with.
   */
  provider?: string | undefined;
  read?: BaseReadConfig | undefined;
  write?: BaseWriteConfig | undefined;
  proxy?: UpdateInstallationBaseProxyConfig | undefined;
};

/**
 * The config of the installation.
 */
export type UpdateInstallationConfig = {
  /**
   * The ID of the revision that this config is based on.
   */
  revisionId?: string | undefined;
  /**
   * The person who created the config, in the format of "consumer:{consumer-id}" or "builder:{builder-id}".
   */
  createdBy?: string | undefined;
  /**
   * The content of the config.
   */
  content?: UpdateInstallationConfigContent | undefined;
};

/**
 * The installation fields to update. (Only include the fields you'd like to update.)
 */
export type Installation = {
  /**
   * The ID of the SaaS connection tied to this installation.
   */
  connectionId?: string | undefined;
  /**
   * The config of the installation.
   */
  config?: UpdateInstallationConfig | undefined;
};

export type UpdateInstallationRequestBody = {
  updateMask: Array<string>;
  /**
   * The installation fields to update. (Only include the fields you'd like to update.)
   */
  installation: Installation;
};

export type UpdateInstallationRequest = {
  /**
   * The Ampersand project ID or project name.
   */
  projectIdOrName: string;
  /**
   * The integration ID.
   */
  integrationId: string;
  /**
   * The Ampersand installation ID.
   */
  installationId: string;
  requestBody: UpdateInstallationRequestBody;
};

/**
 * A Problem Details object (RFC 9457).
 *
 * @remarks
 *
 * Additional properties specific to the problem type may be present.
 */
export type UpdateInstallationAPIProblem = {
  /**
   * An absolute URI that identifies the problem type
   */
  type?: string | undefined;
  /**
   * An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
   */
  href?: string | undefined;
  /**
   * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
   */
  title?: string | undefined;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   */
  status?: number | undefined;
  /**
   * A human-readable explanation specific to this occurrence of the problem
   */
  detail?: string | undefined;
  /**
   * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   */
  instance?: string | undefined;
  /**
   * The subsystem that generated the problem
   */
  subsystem?: string | undefined;
  /**
   * The time the problem occurred, formatted as RFC-3339
   */
  time?: Date | undefined;
  /**
   * A unique identifier for the request, useful for debugging
   */
  requestId?: string | undefined;
  /**
   * A list of problems that caused this problem. This can be used to represent multiple
   *
   * @remarks
   * root causes. There is no guaranteed ordering of the causes.
   */
  causes?: Array<string> | undefined;
  /**
   * A brief description of how to resolve the problem
   */
  remedy?: string | undefined;
  /**
   * An email address to contact for support
   */
  supportEmail?: string | undefined;
  /**
   * A phone number to contact for support
   */
  supportPhone?: string | undefined;
  /**
   * A URL to contact for support
   */
  supportUrl?: string | undefined;
  /**
   * Whether the request can be retried
   */
  retryable?: boolean | undefined;
  /**
   * A timestamp after which the request can be retried, formatted as RFC-3339
   */
  retryAfter?: Date | undefined;
  /**
   * Additional context for the problem
   */
  context?: { [k: string]: any } | undefined;
};

export type UpdateInstallationGroup = {
  /**
   * The ID of the user group that has access to this installation.
   */
  groupRef: string;
  /**
   * The name of the user group that has access to this installation.
   */
  groupName: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The time the group was created.
   */
  createTime: Date;
  /**
   * The time the group was last updated.
   */
  updateTime?: Date | undefined;
};

export type UpdateInstallationProviderApp = {
  /**
   * The provider app ID.
   */
  id: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The ID used by the provider to identify the app (optional).
   */
  externalRef?: string | undefined;
  /**
   * The SaaS provider that this app connects to.
   */
  provider: string;
  /**
   * The OAuth client ID for this app.
   */
  clientId: string;
  /**
   * The OAuth scopes for this app.
   */
  scopes?: Array<string> | undefined;
  /**
   * The time the provider app was created.
   */
  createTime: Date;
  /**
   * The time the provider app was updated.
   */
  updateTime?: Date | undefined;
};

export type UpdateInstallationInstallationsGroup = {
  /**
   * The ID of the user group that has access to this installation.
   */
  groupRef: string;
  /**
   * The name of the user group that has access to this installation.
   */
  groupName: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The time the group was created.
   */
  createTime: Date;
  /**
   * The time the group was last updated.
   */
  updateTime?: Date | undefined;
};

export type UpdateInstallationConsumer = {
  /**
   * The consumer reference.
   */
  consumerRef: string;
  /**
   * The name of the consumer.
   */
  consumerName: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The time the consumer was created.
   */
  createTime: Date;
  /**
   * The time the consumer was last updated.
   */
  updateTime?: Date | undefined;
};

/**
 * The authentication scheme used for this connection.
 */
export const UpdateInstallationAuthScheme = {
  None: "none",
  ApiKey: "apiKey",
  Basic: "basic",
  Oauth2AuthorizationCode: "oauth2/authorizationCode",
  Oauth2AuthorizationCodePKCE: "oauth2/authorizationCodePKCE",
  Oauth2ClientCredentials: "oauth2/clientCredentials",
  Oauth2Password: "oauth2/password",
} as const;
/**
 * The authentication scheme used for this connection.
 */
export type UpdateInstallationAuthScheme = ClosedEnum<
  typeof UpdateInstallationAuthScheme
>;

/**
 * The status of the connection.
 */
export const UpdateInstallationStatus = {
  Created: "created",
  Working: "working",
  BadCredentials: "bad_credentials",
} as const;
/**
 * The status of the connection.
 */
export type UpdateInstallationStatus = ClosedEnum<
  typeof UpdateInstallationStatus
>;

/**
 * The access token for the connection.
 */
export type UpdateInstallationAccessToken = {
  token: string;
  issuedAt?: Date | undefined;
  expiresAt?: Date | undefined;
};

/**
 * The refresh token to use for the connection.
 */
export type UpdateInstallationRefreshToken = {
  token: string;
  issuedAt?: Date | undefined;
  expiresAt?: Date | undefined;
};

export type UpdateInstallationOAuth2AuthorizationCodeToken = {
  /**
   * The access token for the connection.
   */
  accessToken?: UpdateInstallationAccessToken | undefined;
  /**
   * The refresh token to use for the connection.
   */
  refreshToken?: UpdateInstallationRefreshToken | undefined;
  /**
   * The scopes for the tokens.
   */
  scopes?: Array<string> | undefined;
};

export type UpdateInstallationConnection = {
  /**
   * The connection ID.
   */
  id: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The SaaS provider that this Connection is for.
   */
  provider: string;
  providerApp?: UpdateInstallationProviderApp | undefined;
  group: UpdateInstallationInstallationsGroup;
  consumer: UpdateInstallationConsumer;
  /**
   * If available, the identifier for the provider workspace (e.g. the Salesforce subdomain)
   */
  providerWorkspaceRef?: string | undefined;
  /**
   * If available, the ID that Salesforce/Hubspot uses to identify this user (e.g. Salesforce has IDs in the form of https://login.salesforce.com/id/00D4x0000019CQTEA2/0054x000000orJ4AA)
   */
  providerConsumerRef?: string | undefined;
  /**
   * The time the connection was created.
   */
  createTime: Date;
  /**
   * The time the connection was last updated.
   */
  updateTime?: Date | undefined;
  /**
   * The authentication scheme used for this connection.
   */
  authScheme: UpdateInstallationAuthScheme;
  /**
   * The status of the connection.
   */
  status: UpdateInstallationStatus;
  oauth2AuthorizationCode?:
    | UpdateInstallationOAuth2AuthorizationCodeToken
    | undefined;
  /**
   * The API key used while making the connection.
   */
  apiKey?: string | undefined;
};

export type UpdateInstallationInstallationsBaseProxyConfig = {
  enabled?: boolean | undefined;
};

export type UpdateInstallationInstallationsConfigContent = {
  /**
   * The SaaS API that we are integrating with.
   */
  provider: string;
  read?: any | undefined;
  write?: any | undefined;
  proxy?: UpdateInstallationInstallationsBaseProxyConfig | undefined;
};

export type UpdateInstallationInstallationsConfig = {
  /**
   * The config ID.
   */
  id: string;
  /**
   * The ID of the revision that this config is based on.
   */
  revisionId: string;
  /**
   * The time the config was created.
   */
  createTime: Date;
  /**
   * The person who created the config, in the format of "consumer:{consumer-id}" or "builder:{builder-id}".
   */
  createdBy: string;
  content: UpdateInstallationInstallationsConfigContent;
};

/**
 * The updated installation
 */
export type UpdateInstallationInstallation = {
  /**
   * The installation ID.
   */
  id: string;
  /**
   * The Ampersand project ID.
   */
  projectId: string;
  /**
   * The integration ID.
   */
  integrationId: string;
  group?: UpdateInstallationGroup | undefined;
  /**
   * The health status of the installation ("healthy", "unhealthy").
   */
  healthStatus: string;
  connection: UpdateInstallationConnection;
  /**
   * The time the integration was first installed.
   */
  createTime: Date;
  /**
   * The person who did the installation, in the format of "consumer:{consumer-id}".
   */
  createdBy: string;
  /**
   * The time the installation was last updated with a new config.
   */
  updateTime?: Date | undefined;
  config: UpdateInstallationInstallationsConfig;
};

export type UpdateInstallationResponse =
  | UpdateInstallationInstallation
  | UpdateInstallationAPIProblem;

/** @internal */
export const SelectedFieldsAutoConfig$inboundSchema: z.ZodNativeEnum<
  typeof SelectedFieldsAutoConfig
> = z.nativeEnum(SelectedFieldsAutoConfig);

/** @internal */
export const SelectedFieldsAutoConfig$outboundSchema: z.ZodNativeEnum<
  typeof SelectedFieldsAutoConfig
> = SelectedFieldsAutoConfig$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SelectedFieldsAutoConfig$ {
  /** @deprecated use `SelectedFieldsAutoConfig$inboundSchema` instead. */
  export const inboundSchema = SelectedFieldsAutoConfig$inboundSchema;
  /** @deprecated use `SelectedFieldsAutoConfig$outboundSchema` instead. */
  export const outboundSchema = SelectedFieldsAutoConfig$outboundSchema;
}

/** @internal */
export const DefaultPeriodConfig$inboundSchema: z.ZodType<
  DefaultPeriodConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/** @internal */
export type DefaultPeriodConfig$Outbound = {
  days?: number | undefined;
  fullHistory?: boolean | undefined;
};

/** @internal */
export const DefaultPeriodConfig$outboundSchema: z.ZodType<
  DefaultPeriodConfig$Outbound,
  z.ZodTypeDef,
  DefaultPeriodConfig
> = z.object({
  days: z.number().int().optional(),
  fullHistory: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultPeriodConfig$ {
  /** @deprecated use `DefaultPeriodConfig$inboundSchema` instead. */
  export const inboundSchema = DefaultPeriodConfig$inboundSchema;
  /** @deprecated use `DefaultPeriodConfig$outboundSchema` instead. */
  export const outboundSchema = DefaultPeriodConfig$outboundSchema;
  /** @deprecated use `DefaultPeriodConfig$Outbound` instead. */
  export type Outbound = DefaultPeriodConfig$Outbound;
}

export function defaultPeriodConfigToJSON(
  defaultPeriodConfig: DefaultPeriodConfig,
): string {
  return JSON.stringify(
    DefaultPeriodConfig$outboundSchema.parse(defaultPeriodConfig),
  );
}

export function defaultPeriodConfigFromJSON(
  jsonString: string,
): SafeParseResult<DefaultPeriodConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultPeriodConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultPeriodConfig' from JSON`,
  );
}

/** @internal */
export const BackfillConfig$inboundSchema: z.ZodType<
  BackfillConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  defaultPeriod: z.lazy(() => DefaultPeriodConfig$inboundSchema),
});

/** @internal */
export type BackfillConfig$Outbound = {
  defaultPeriod: DefaultPeriodConfig$Outbound;
};

/** @internal */
export const BackfillConfig$outboundSchema: z.ZodType<
  BackfillConfig$Outbound,
  z.ZodTypeDef,
  BackfillConfig
> = z.object({
  defaultPeriod: z.lazy(() => DefaultPeriodConfig$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackfillConfig$ {
  /** @deprecated use `BackfillConfig$inboundSchema` instead. */
  export const inboundSchema = BackfillConfig$inboundSchema;
  /** @deprecated use `BackfillConfig$outboundSchema` instead. */
  export const outboundSchema = BackfillConfig$outboundSchema;
  /** @deprecated use `BackfillConfig$Outbound` instead. */
  export type Outbound = BackfillConfig$Outbound;
}

export function backfillConfigToJSON(backfillConfig: BackfillConfig): string {
  return JSON.stringify(BackfillConfig$outboundSchema.parse(backfillConfig));
}

export function backfillConfigFromJSON(
  jsonString: string,
): SafeParseResult<BackfillConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BackfillConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BackfillConfig' from JSON`,
  );
}

/** @internal */
export const BaseReadConfigObject$inboundSchema: z.ZodType<
  BaseReadConfigObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string().optional(),
  schedule: z.string().optional(),
  destination: z.string().optional(),
  selectedFields: z.record(z.boolean()).optional(),
  selectedValueMappings: z.record(z.record(z.string())).optional(),
  selectedFieldMappings: z.record(z.string()).optional(),
  selectedFieldsAuto: SelectedFieldsAutoConfig$inboundSchema.optional(),
  backfill: z.lazy(() => BackfillConfig$inboundSchema).optional(),
});

/** @internal */
export type BaseReadConfigObject$Outbound = {
  objectName?: string | undefined;
  schedule?: string | undefined;
  destination?: string | undefined;
  selectedFields?: { [k: string]: boolean } | undefined;
  selectedValueMappings?: { [k: string]: { [k: string]: string } } | undefined;
  selectedFieldMappings?: { [k: string]: string } | undefined;
  selectedFieldsAuto?: string | undefined;
  backfill?: BackfillConfig$Outbound | undefined;
};

/** @internal */
export const BaseReadConfigObject$outboundSchema: z.ZodType<
  BaseReadConfigObject$Outbound,
  z.ZodTypeDef,
  BaseReadConfigObject
> = z.object({
  objectName: z.string().optional(),
  schedule: z.string().optional(),
  destination: z.string().optional(),
  selectedFields: z.record(z.boolean()).optional(),
  selectedValueMappings: z.record(z.record(z.string())).optional(),
  selectedFieldMappings: z.record(z.string()).optional(),
  selectedFieldsAuto: SelectedFieldsAutoConfig$outboundSchema.optional(),
  backfill: z.lazy(() => BackfillConfig$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BaseReadConfigObject$ {
  /** @deprecated use `BaseReadConfigObject$inboundSchema` instead. */
  export const inboundSchema = BaseReadConfigObject$inboundSchema;
  /** @deprecated use `BaseReadConfigObject$outboundSchema` instead. */
  export const outboundSchema = BaseReadConfigObject$outboundSchema;
  /** @deprecated use `BaseReadConfigObject$Outbound` instead. */
  export type Outbound = BaseReadConfigObject$Outbound;
}

export function baseReadConfigObjectToJSON(
  baseReadConfigObject: BaseReadConfigObject,
): string {
  return JSON.stringify(
    BaseReadConfigObject$outboundSchema.parse(baseReadConfigObject),
  );
}

export function baseReadConfigObjectFromJSON(
  jsonString: string,
): SafeParseResult<BaseReadConfigObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BaseReadConfigObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BaseReadConfigObject' from JSON`,
  );
}

/** @internal */
export const BaseReadConfig$inboundSchema: z.ZodType<
  BaseReadConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  objects: z.record(z.lazy(() => BaseReadConfigObject$inboundSchema))
    .optional(),
});

/** @internal */
export type BaseReadConfig$Outbound = {
  objects?: { [k: string]: BaseReadConfigObject$Outbound } | undefined;
};

/** @internal */
export const BaseReadConfig$outboundSchema: z.ZodType<
  BaseReadConfig$Outbound,
  z.ZodTypeDef,
  BaseReadConfig
> = z.object({
  objects: z.record(z.lazy(() => BaseReadConfigObject$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BaseReadConfig$ {
  /** @deprecated use `BaseReadConfig$inboundSchema` instead. */
  export const inboundSchema = BaseReadConfig$inboundSchema;
  /** @deprecated use `BaseReadConfig$outboundSchema` instead. */
  export const outboundSchema = BaseReadConfig$outboundSchema;
  /** @deprecated use `BaseReadConfig$Outbound` instead. */
  export type Outbound = BaseReadConfig$Outbound;
}

export function baseReadConfigToJSON(baseReadConfig: BaseReadConfig): string {
  return JSON.stringify(BaseReadConfig$outboundSchema.parse(baseReadConfig));
}

export function baseReadConfigFromJSON(
  jsonString: string,
): SafeParseResult<BaseReadConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BaseReadConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BaseReadConfig' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationValueDefaultLegacyApplyOnUpdate$inboundSchema:
  z.ZodNativeEnum<typeof UpdateInstallationValueDefaultLegacyApplyOnUpdate> = z
    .nativeEnum(UpdateInstallationValueDefaultLegacyApplyOnUpdate);

/** @internal */
export const UpdateInstallationValueDefaultLegacyApplyOnUpdate$outboundSchema:
  z.ZodNativeEnum<typeof UpdateInstallationValueDefaultLegacyApplyOnUpdate> =
    UpdateInstallationValueDefaultLegacyApplyOnUpdate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationValueDefaultLegacyApplyOnUpdate$ {
  /** @deprecated use `UpdateInstallationValueDefaultLegacyApplyOnUpdate$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationValueDefaultLegacyApplyOnUpdate$inboundSchema;
  /** @deprecated use `UpdateInstallationValueDefaultLegacyApplyOnUpdate$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationValueDefaultLegacyApplyOnUpdate$outboundSchema;
}

/** @internal */
export const ValueDefaultBoolean$inboundSchema: z.ZodType<
  ValueDefaultBoolean,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.boolean(),
  applyOnUpdate: UpdateInstallationValueDefaultLegacyApplyOnUpdate$inboundSchema
    .optional(),
});

/** @internal */
export type ValueDefaultBoolean$Outbound = {
  value: boolean;
  applyOnUpdate?: string | undefined;
};

/** @internal */
export const ValueDefaultBoolean$outboundSchema: z.ZodType<
  ValueDefaultBoolean$Outbound,
  z.ZodTypeDef,
  ValueDefaultBoolean
> = z.object({
  value: z.boolean(),
  applyOnUpdate:
    UpdateInstallationValueDefaultLegacyApplyOnUpdate$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValueDefaultBoolean$ {
  /** @deprecated use `ValueDefaultBoolean$inboundSchema` instead. */
  export const inboundSchema = ValueDefaultBoolean$inboundSchema;
  /** @deprecated use `ValueDefaultBoolean$outboundSchema` instead. */
  export const outboundSchema = ValueDefaultBoolean$outboundSchema;
  /** @deprecated use `ValueDefaultBoolean$Outbound` instead. */
  export type Outbound = ValueDefaultBoolean$Outbound;
}

export function valueDefaultBooleanToJSON(
  valueDefaultBoolean: ValueDefaultBoolean,
): string {
  return JSON.stringify(
    ValueDefaultBoolean$outboundSchema.parse(valueDefaultBoolean),
  );
}

export function valueDefaultBooleanFromJSON(
  jsonString: string,
): SafeParseResult<ValueDefaultBoolean, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValueDefaultBoolean$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValueDefaultBoolean' from JSON`,
  );
}

/** @internal */
export const ValueDefaultLegacyApplyOnUpdate$inboundSchema: z.ZodNativeEnum<
  typeof ValueDefaultLegacyApplyOnUpdate
> = z.nativeEnum(ValueDefaultLegacyApplyOnUpdate);

/** @internal */
export const ValueDefaultLegacyApplyOnUpdate$outboundSchema: z.ZodNativeEnum<
  typeof ValueDefaultLegacyApplyOnUpdate
> = ValueDefaultLegacyApplyOnUpdate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValueDefaultLegacyApplyOnUpdate$ {
  /** @deprecated use `ValueDefaultLegacyApplyOnUpdate$inboundSchema` instead. */
  export const inboundSchema = ValueDefaultLegacyApplyOnUpdate$inboundSchema;
  /** @deprecated use `ValueDefaultLegacyApplyOnUpdate$outboundSchema` instead. */
  export const outboundSchema = ValueDefaultLegacyApplyOnUpdate$outboundSchema;
}

/** @internal */
export const ValueDefaultInteger$inboundSchema: z.ZodType<
  ValueDefaultInteger,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.number().int(),
  applyOnUpdate: ValueDefaultLegacyApplyOnUpdate$inboundSchema.optional(),
});

/** @internal */
export type ValueDefaultInteger$Outbound = {
  value: number;
  applyOnUpdate?: string | undefined;
};

/** @internal */
export const ValueDefaultInteger$outboundSchema: z.ZodType<
  ValueDefaultInteger$Outbound,
  z.ZodTypeDef,
  ValueDefaultInteger
> = z.object({
  value: z.number().int(),
  applyOnUpdate: ValueDefaultLegacyApplyOnUpdate$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValueDefaultInteger$ {
  /** @deprecated use `ValueDefaultInteger$inboundSchema` instead. */
  export const inboundSchema = ValueDefaultInteger$inboundSchema;
  /** @deprecated use `ValueDefaultInteger$outboundSchema` instead. */
  export const outboundSchema = ValueDefaultInteger$outboundSchema;
  /** @deprecated use `ValueDefaultInteger$Outbound` instead. */
  export type Outbound = ValueDefaultInteger$Outbound;
}

export function valueDefaultIntegerToJSON(
  valueDefaultInteger: ValueDefaultInteger,
): string {
  return JSON.stringify(
    ValueDefaultInteger$outboundSchema.parse(valueDefaultInteger),
  );
}

export function valueDefaultIntegerFromJSON(
  jsonString: string,
): SafeParseResult<ValueDefaultInteger, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValueDefaultInteger$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValueDefaultInteger' from JSON`,
  );
}

/** @internal */
export const ApplyOnUpdate$inboundSchema: z.ZodNativeEnum<
  typeof ApplyOnUpdate
> = z.nativeEnum(ApplyOnUpdate);

/** @internal */
export const ApplyOnUpdate$outboundSchema: z.ZodNativeEnum<
  typeof ApplyOnUpdate
> = ApplyOnUpdate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ApplyOnUpdate$ {
  /** @deprecated use `ApplyOnUpdate$inboundSchema` instead. */
  export const inboundSchema = ApplyOnUpdate$inboundSchema;
  /** @deprecated use `ApplyOnUpdate$outboundSchema` instead. */
  export const outboundSchema = ApplyOnUpdate$outboundSchema;
}

/** @internal */
export const ValueDefaultString$inboundSchema: z.ZodType<
  ValueDefaultString,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  applyOnUpdate: ApplyOnUpdate$inboundSchema.optional(),
});

/** @internal */
export type ValueDefaultString$Outbound = {
  value: string;
  applyOnUpdate?: string | undefined;
};

/** @internal */
export const ValueDefaultString$outboundSchema: z.ZodType<
  ValueDefaultString$Outbound,
  z.ZodTypeDef,
  ValueDefaultString
> = z.object({
  value: z.string(),
  applyOnUpdate: ApplyOnUpdate$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValueDefaultString$ {
  /** @deprecated use `ValueDefaultString$inboundSchema` instead. */
  export const inboundSchema = ValueDefaultString$inboundSchema;
  /** @deprecated use `ValueDefaultString$outboundSchema` instead. */
  export const outboundSchema = ValueDefaultString$outboundSchema;
  /** @deprecated use `ValueDefaultString$Outbound` instead. */
  export type Outbound = ValueDefaultString$Outbound;
}

export function valueDefaultStringToJSON(
  valueDefaultString: ValueDefaultString,
): string {
  return JSON.stringify(
    ValueDefaultString$outboundSchema.parse(valueDefaultString),
  );
}

export function valueDefaultStringFromJSON(
  jsonString: string,
): SafeParseResult<ValueDefaultString, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValueDefaultString$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValueDefaultString' from JSON`,
  );
}

/** @internal */
export const ValueDefaultLegacy$inboundSchema: z.ZodType<
  ValueDefaultLegacy,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ValueDefaultString$inboundSchema),
  z.lazy(() => ValueDefaultInteger$inboundSchema),
  z.lazy(() => ValueDefaultBoolean$inboundSchema),
]);

/** @internal */
export type ValueDefaultLegacy$Outbound =
  | ValueDefaultString$Outbound
  | ValueDefaultInteger$Outbound
  | ValueDefaultBoolean$Outbound;

/** @internal */
export const ValueDefaultLegacy$outboundSchema: z.ZodType<
  ValueDefaultLegacy$Outbound,
  z.ZodTypeDef,
  ValueDefaultLegacy
> = z.union([
  z.lazy(() => ValueDefaultString$outboundSchema),
  z.lazy(() => ValueDefaultInteger$outboundSchema),
  z.lazy(() => ValueDefaultBoolean$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValueDefaultLegacy$ {
  /** @deprecated use `ValueDefaultLegacy$inboundSchema` instead. */
  export const inboundSchema = ValueDefaultLegacy$inboundSchema;
  /** @deprecated use `ValueDefaultLegacy$outboundSchema` instead. */
  export const outboundSchema = ValueDefaultLegacy$outboundSchema;
  /** @deprecated use `ValueDefaultLegacy$Outbound` instead. */
  export type Outbound = ValueDefaultLegacy$Outbound;
}

export function valueDefaultLegacyToJSON(
  valueDefaultLegacy: ValueDefaultLegacy,
): string {
  return JSON.stringify(
    ValueDefaultLegacy$outboundSchema.parse(valueDefaultLegacy),
  );
}

export function valueDefaultLegacyFromJSON(
  jsonString: string,
): SafeParseResult<ValueDefaultLegacy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValueDefaultLegacy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValueDefaultLegacy' from JSON`,
  );
}

/** @internal */
export const DefaultValueForAField$inboundSchema: z.ZodType<
  DefaultValueForAField,
  z.ZodTypeDef,
  unknown
> = z.object({
  stringValue: z.string().optional(),
  integerValue: z.number().int().optional(),
  booleanValue: z.boolean().optional(),
});

/** @internal */
export type DefaultValueForAField$Outbound = {
  stringValue?: string | undefined;
  integerValue?: number | undefined;
  booleanValue?: boolean | undefined;
};

/** @internal */
export const DefaultValueForAField$outboundSchema: z.ZodType<
  DefaultValueForAField$Outbound,
  z.ZodTypeDef,
  DefaultValueForAField
> = z.object({
  stringValue: z.string().optional(),
  integerValue: z.number().int().optional(),
  booleanValue: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultValueForAField$ {
  /** @deprecated use `DefaultValueForAField$inboundSchema` instead. */
  export const inboundSchema = DefaultValueForAField$inboundSchema;
  /** @deprecated use `DefaultValueForAField$outboundSchema` instead. */
  export const outboundSchema = DefaultValueForAField$outboundSchema;
  /** @deprecated use `DefaultValueForAField$Outbound` instead. */
  export type Outbound = DefaultValueForAField$Outbound;
}

export function defaultValueForAFieldToJSON(
  defaultValueForAField: DefaultValueForAField,
): string {
  return JSON.stringify(
    DefaultValueForAField$outboundSchema.parse(defaultValueForAField),
  );
}

export function defaultValueForAFieldFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValueForAField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValueForAField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValueForAField' from JSON`,
  );
}

/** @internal */
export const WriteOnCreate$inboundSchema: z.ZodNativeEnum<
  typeof WriteOnCreate
> = z.nativeEnum(WriteOnCreate);

/** @internal */
export const WriteOnCreate$outboundSchema: z.ZodNativeEnum<
  typeof WriteOnCreate
> = WriteOnCreate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WriteOnCreate$ {
  /** @deprecated use `WriteOnCreate$inboundSchema` instead. */
  export const inboundSchema = WriteOnCreate$inboundSchema;
  /** @deprecated use `WriteOnCreate$outboundSchema` instead. */
  export const outboundSchema = WriteOnCreate$outboundSchema;
}

/** @internal */
export const WriteOnUpdate$inboundSchema: z.ZodNativeEnum<
  typeof WriteOnUpdate
> = z.nativeEnum(WriteOnUpdate);

/** @internal */
export const WriteOnUpdate$outboundSchema: z.ZodNativeEnum<
  typeof WriteOnUpdate
> = WriteOnUpdate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WriteOnUpdate$ {
  /** @deprecated use `WriteOnUpdate$inboundSchema` instead. */
  export const inboundSchema = WriteOnUpdate$inboundSchema;
  /** @deprecated use `WriteOnUpdate$outboundSchema` instead. */
  export const outboundSchema = WriteOnUpdate$outboundSchema;
}

/** @internal */
export const FieldSetting$inboundSchema: z.ZodType<
  FieldSetting,
  z.ZodTypeDef,
  unknown
> = z.object({
  default: z.lazy(() => DefaultValueForAField$inboundSchema).optional(),
  writeOnCreate: WriteOnCreate$inboundSchema.default("always"),
  writeOnUpdate: WriteOnUpdate$inboundSchema.default("always"),
});

/** @internal */
export type FieldSetting$Outbound = {
  default?: DefaultValueForAField$Outbound | undefined;
  writeOnCreate: string;
  writeOnUpdate: string;
};

/** @internal */
export const FieldSetting$outboundSchema: z.ZodType<
  FieldSetting$Outbound,
  z.ZodTypeDef,
  FieldSetting
> = z.object({
  default: z.lazy(() => DefaultValueForAField$outboundSchema).optional(),
  writeOnCreate: WriteOnCreate$outboundSchema.default("always"),
  writeOnUpdate: WriteOnUpdate$outboundSchema.default("always"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FieldSetting$ {
  /** @deprecated use `FieldSetting$inboundSchema` instead. */
  export const inboundSchema = FieldSetting$inboundSchema;
  /** @deprecated use `FieldSetting$outboundSchema` instead. */
  export const outboundSchema = FieldSetting$outboundSchema;
  /** @deprecated use `FieldSetting$Outbound` instead. */
  export type Outbound = FieldSetting$Outbound;
}

export function fieldSettingToJSON(fieldSetting: FieldSetting): string {
  return JSON.stringify(FieldSetting$outboundSchema.parse(fieldSetting));
}

export function fieldSettingFromJSON(
  jsonString: string,
): SafeParseResult<FieldSetting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FieldSetting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FieldSetting' from JSON`,
  );
}

/** @internal */
export const BaseWriteConfigObject$inboundSchema: z.ZodType<
  BaseWriteConfigObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  objectName: z.string(),
  selectedValueDefaults: z.record(
    z.union([
      z.lazy(() => ValueDefaultString$inboundSchema),
      z.lazy(() => ValueDefaultInteger$inboundSchema),
      z.lazy(() => ValueDefaultBoolean$inboundSchema),
    ]),
  ).optional(),
  selectedFieldSettings: z.record(z.lazy(() => FieldSetting$inboundSchema))
    .optional(),
});

/** @internal */
export type BaseWriteConfigObject$Outbound = {
  objectName: string;
  selectedValueDefaults?: {
    [k: string]:
      | ValueDefaultString$Outbound
      | ValueDefaultInteger$Outbound
      | ValueDefaultBoolean$Outbound;
  } | undefined;
  selectedFieldSettings?: { [k: string]: FieldSetting$Outbound } | undefined;
};

/** @internal */
export const BaseWriteConfigObject$outboundSchema: z.ZodType<
  BaseWriteConfigObject$Outbound,
  z.ZodTypeDef,
  BaseWriteConfigObject
> = z.object({
  objectName: z.string(),
  selectedValueDefaults: z.record(
    z.union([
      z.lazy(() => ValueDefaultString$outboundSchema),
      z.lazy(() => ValueDefaultInteger$outboundSchema),
      z.lazy(() => ValueDefaultBoolean$outboundSchema),
    ]),
  ).optional(),
  selectedFieldSettings: z.record(z.lazy(() => FieldSetting$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BaseWriteConfigObject$ {
  /** @deprecated use `BaseWriteConfigObject$inboundSchema` instead. */
  export const inboundSchema = BaseWriteConfigObject$inboundSchema;
  /** @deprecated use `BaseWriteConfigObject$outboundSchema` instead. */
  export const outboundSchema = BaseWriteConfigObject$outboundSchema;
  /** @deprecated use `BaseWriteConfigObject$Outbound` instead. */
  export type Outbound = BaseWriteConfigObject$Outbound;
}

export function baseWriteConfigObjectToJSON(
  baseWriteConfigObject: BaseWriteConfigObject,
): string {
  return JSON.stringify(
    BaseWriteConfigObject$outboundSchema.parse(baseWriteConfigObject),
  );
}

export function baseWriteConfigObjectFromJSON(
  jsonString: string,
): SafeParseResult<BaseWriteConfigObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BaseWriteConfigObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BaseWriteConfigObject' from JSON`,
  );
}

/** @internal */
export const BaseWriteConfig$inboundSchema: z.ZodType<
  BaseWriteConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  objects: z.record(z.lazy(() => BaseWriteConfigObject$inboundSchema))
    .optional(),
});

/** @internal */
export type BaseWriteConfig$Outbound = {
  objects?: { [k: string]: BaseWriteConfigObject$Outbound } | undefined;
};

/** @internal */
export const BaseWriteConfig$outboundSchema: z.ZodType<
  BaseWriteConfig$Outbound,
  z.ZodTypeDef,
  BaseWriteConfig
> = z.object({
  objects: z.record(z.lazy(() => BaseWriteConfigObject$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BaseWriteConfig$ {
  /** @deprecated use `BaseWriteConfig$inboundSchema` instead. */
  export const inboundSchema = BaseWriteConfig$inboundSchema;
  /** @deprecated use `BaseWriteConfig$outboundSchema` instead. */
  export const outboundSchema = BaseWriteConfig$outboundSchema;
  /** @deprecated use `BaseWriteConfig$Outbound` instead. */
  export type Outbound = BaseWriteConfig$Outbound;
}

export function baseWriteConfigToJSON(
  baseWriteConfig: BaseWriteConfig,
): string {
  return JSON.stringify(BaseWriteConfig$outboundSchema.parse(baseWriteConfig));
}

export function baseWriteConfigFromJSON(
  jsonString: string,
): SafeParseResult<BaseWriteConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BaseWriteConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BaseWriteConfig' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationBaseProxyConfig$inboundSchema: z.ZodType<
  UpdateInstallationBaseProxyConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});

/** @internal */
export type UpdateInstallationBaseProxyConfig$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const UpdateInstallationBaseProxyConfig$outboundSchema: z.ZodType<
  UpdateInstallationBaseProxyConfig$Outbound,
  z.ZodTypeDef,
  UpdateInstallationBaseProxyConfig
> = z.object({
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationBaseProxyConfig$ {
  /** @deprecated use `UpdateInstallationBaseProxyConfig$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationBaseProxyConfig$inboundSchema;
  /** @deprecated use `UpdateInstallationBaseProxyConfig$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationBaseProxyConfig$outboundSchema;
  /** @deprecated use `UpdateInstallationBaseProxyConfig$Outbound` instead. */
  export type Outbound = UpdateInstallationBaseProxyConfig$Outbound;
}

export function updateInstallationBaseProxyConfigToJSON(
  updateInstallationBaseProxyConfig: UpdateInstallationBaseProxyConfig,
): string {
  return JSON.stringify(
    UpdateInstallationBaseProxyConfig$outboundSchema.parse(
      updateInstallationBaseProxyConfig,
    ),
  );
}

export function updateInstallationBaseProxyConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationBaseProxyConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationBaseProxyConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationBaseProxyConfig' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConfigContent$inboundSchema: z.ZodType<
  UpdateInstallationConfigContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  provider: z.string().optional(),
  read: z.lazy(() => BaseReadConfig$inboundSchema).optional(),
  write: z.lazy(() => BaseWriteConfig$inboundSchema).optional(),
  proxy: z.lazy(() => UpdateInstallationBaseProxyConfig$inboundSchema)
    .optional(),
});

/** @internal */
export type UpdateInstallationConfigContent$Outbound = {
  provider?: string | undefined;
  read?: BaseReadConfig$Outbound | undefined;
  write?: BaseWriteConfig$Outbound | undefined;
  proxy?: UpdateInstallationBaseProxyConfig$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationConfigContent$outboundSchema: z.ZodType<
  UpdateInstallationConfigContent$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConfigContent
> = z.object({
  provider: z.string().optional(),
  read: z.lazy(() => BaseReadConfig$outboundSchema).optional(),
  write: z.lazy(() => BaseWriteConfig$outboundSchema).optional(),
  proxy: z.lazy(() => UpdateInstallationBaseProxyConfig$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConfigContent$ {
  /** @deprecated use `UpdateInstallationConfigContent$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConfigContent$inboundSchema;
  /** @deprecated use `UpdateInstallationConfigContent$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConfigContent$outboundSchema;
  /** @deprecated use `UpdateInstallationConfigContent$Outbound` instead. */
  export type Outbound = UpdateInstallationConfigContent$Outbound;
}

export function updateInstallationConfigContentToJSON(
  updateInstallationConfigContent: UpdateInstallationConfigContent,
): string {
  return JSON.stringify(
    UpdateInstallationConfigContent$outboundSchema.parse(
      updateInstallationConfigContent,
    ),
  );
}

export function updateInstallationConfigContentFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConfigContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConfigContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConfigContent' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConfig$inboundSchema: z.ZodType<
  UpdateInstallationConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  revisionId: z.string().optional(),
  createdBy: z.string().optional(),
  content: z.lazy(() => UpdateInstallationConfigContent$inboundSchema)
    .optional(),
});

/** @internal */
export type UpdateInstallationConfig$Outbound = {
  revisionId?: string | undefined;
  createdBy?: string | undefined;
  content?: UpdateInstallationConfigContent$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationConfig$outboundSchema: z.ZodType<
  UpdateInstallationConfig$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConfig
> = z.object({
  revisionId: z.string().optional(),
  createdBy: z.string().optional(),
  content: z.lazy(() => UpdateInstallationConfigContent$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConfig$ {
  /** @deprecated use `UpdateInstallationConfig$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConfig$inboundSchema;
  /** @deprecated use `UpdateInstallationConfig$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConfig$outboundSchema;
  /** @deprecated use `UpdateInstallationConfig$Outbound` instead. */
  export type Outbound = UpdateInstallationConfig$Outbound;
}

export function updateInstallationConfigToJSON(
  updateInstallationConfig: UpdateInstallationConfig,
): string {
  return JSON.stringify(
    UpdateInstallationConfig$outboundSchema.parse(updateInstallationConfig),
  );
}

export function updateInstallationConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConfig' from JSON`,
  );
}

/** @internal */
export const Installation$inboundSchema: z.ZodType<
  Installation,
  z.ZodTypeDef,
  unknown
> = z.object({
  connectionId: z.string().optional(),
  config: z.lazy(() => UpdateInstallationConfig$inboundSchema).optional(),
});

/** @internal */
export type Installation$Outbound = {
  connectionId?: string | undefined;
  config?: UpdateInstallationConfig$Outbound | undefined;
};

/** @internal */
export const Installation$outboundSchema: z.ZodType<
  Installation$Outbound,
  z.ZodTypeDef,
  Installation
> = z.object({
  connectionId: z.string().optional(),
  config: z.lazy(() => UpdateInstallationConfig$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Installation$ {
  /** @deprecated use `Installation$inboundSchema` instead. */
  export const inboundSchema = Installation$inboundSchema;
  /** @deprecated use `Installation$outboundSchema` instead. */
  export const outboundSchema = Installation$outboundSchema;
  /** @deprecated use `Installation$Outbound` instead. */
  export type Outbound = Installation$Outbound;
}

export function installationToJSON(installation: Installation): string {
  return JSON.stringify(Installation$outboundSchema.parse(installation));
}

export function installationFromJSON(
  jsonString: string,
): SafeParseResult<Installation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Installation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Installation' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRequestBody$inboundSchema: z.ZodType<
  UpdateInstallationRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  updateMask: z.array(z.string()),
  installation: z.lazy(() => Installation$inboundSchema),
});

/** @internal */
export type UpdateInstallationRequestBody$Outbound = {
  updateMask: Array<string>;
  installation: Installation$Outbound;
};

/** @internal */
export const UpdateInstallationRequestBody$outboundSchema: z.ZodType<
  UpdateInstallationRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRequestBody
> = z.object({
  updateMask: z.array(z.string()),
  installation: z.lazy(() => Installation$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRequestBody$ {
  /** @deprecated use `UpdateInstallationRequestBody$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRequestBody$inboundSchema;
  /** @deprecated use `UpdateInstallationRequestBody$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRequestBody$outboundSchema;
  /** @deprecated use `UpdateInstallationRequestBody$Outbound` instead. */
  export type Outbound = UpdateInstallationRequestBody$Outbound;
}

export function updateInstallationRequestBodyToJSON(
  updateInstallationRequestBody: UpdateInstallationRequestBody,
): string {
  return JSON.stringify(
    UpdateInstallationRequestBody$outboundSchema.parse(
      updateInstallationRequestBody,
    ),
  );
}

export function updateInstallationRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRequest$inboundSchema: z.ZodType<
  UpdateInstallationRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIdOrName: z.string(),
  integrationId: z.string(),
  installationId: z.string(),
  RequestBody: z.lazy(() => UpdateInstallationRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type UpdateInstallationRequest$Outbound = {
  projectIdOrName: string;
  integrationId: string;
  installationId: string;
  RequestBody: UpdateInstallationRequestBody$Outbound;
};

/** @internal */
export const UpdateInstallationRequest$outboundSchema: z.ZodType<
  UpdateInstallationRequest$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRequest
> = z.object({
  projectIdOrName: z.string(),
  integrationId: z.string(),
  installationId: z.string(),
  requestBody: z.lazy(() => UpdateInstallationRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRequest$ {
  /** @deprecated use `UpdateInstallationRequest$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRequest$inboundSchema;
  /** @deprecated use `UpdateInstallationRequest$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRequest$outboundSchema;
  /** @deprecated use `UpdateInstallationRequest$Outbound` instead. */
  export type Outbound = UpdateInstallationRequest$Outbound;
}

export function updateInstallationRequestToJSON(
  updateInstallationRequest: UpdateInstallationRequest,
): string {
  return JSON.stringify(
    UpdateInstallationRequest$outboundSchema.parse(updateInstallationRequest),
  );
}

export function updateInstallationRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRequest' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationAPIProblem$inboundSchema: z.ZodType<
  UpdateInstallationAPIProblem,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  context: z.record(z.any()).optional(),
});

/** @internal */
export type UpdateInstallationAPIProblem$Outbound = {
  type: string;
  href?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  subsystem?: string | undefined;
  time?: string | undefined;
  requestId?: string | undefined;
  causes?: Array<string> | undefined;
  remedy?: string | undefined;
  supportEmail?: string | undefined;
  supportPhone?: string | undefined;
  supportUrl?: string | undefined;
  retryable?: boolean | undefined;
  retryAfter?: string | undefined;
  context?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateInstallationAPIProblem$outboundSchema: z.ZodType<
  UpdateInstallationAPIProblem$Outbound,
  z.ZodTypeDef,
  UpdateInstallationAPIProblem
> = z.object({
  type: z.string().default("about:blank"),
  href: z.string().optional(),
  title: z.string().optional(),
  status: z.number().int().optional(),
  detail: z.string().optional(),
  instance: z.string().optional(),
  subsystem: z.string().optional(),
  time: z.date().transform(v => v.toISOString()).optional(),
  requestId: z.string().optional(),
  causes: z.array(z.string()).optional(),
  remedy: z.string().optional(),
  supportEmail: z.string().optional(),
  supportPhone: z.string().optional(),
  supportUrl: z.string().optional(),
  retryable: z.boolean().optional(),
  retryAfter: z.date().transform(v => v.toISOString()).optional(),
  context: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationAPIProblem$ {
  /** @deprecated use `UpdateInstallationAPIProblem$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationAPIProblem$inboundSchema;
  /** @deprecated use `UpdateInstallationAPIProblem$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationAPIProblem$outboundSchema;
  /** @deprecated use `UpdateInstallationAPIProblem$Outbound` instead. */
  export type Outbound = UpdateInstallationAPIProblem$Outbound;
}

export function updateInstallationAPIProblemToJSON(
  updateInstallationAPIProblem: UpdateInstallationAPIProblem,
): string {
  return JSON.stringify(
    UpdateInstallationAPIProblem$outboundSchema.parse(
      updateInstallationAPIProblem,
    ),
  );
}

export function updateInstallationAPIProblemFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationAPIProblem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationAPIProblem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationAPIProblem' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationGroup$inboundSchema: z.ZodType<
  UpdateInstallationGroup,
  z.ZodTypeDef,
  unknown
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationGroup$Outbound = {
  groupRef: string;
  groupName: string;
  projectId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationGroup$outboundSchema: z.ZodType<
  UpdateInstallationGroup$Outbound,
  z.ZodTypeDef,
  UpdateInstallationGroup
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationGroup$ {
  /** @deprecated use `UpdateInstallationGroup$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationGroup$inboundSchema;
  /** @deprecated use `UpdateInstallationGroup$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationGroup$outboundSchema;
  /** @deprecated use `UpdateInstallationGroup$Outbound` instead. */
  export type Outbound = UpdateInstallationGroup$Outbound;
}

export function updateInstallationGroupToJSON(
  updateInstallationGroup: UpdateInstallationGroup,
): string {
  return JSON.stringify(
    UpdateInstallationGroup$outboundSchema.parse(updateInstallationGroup),
  );
}

export function updateInstallationGroupFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationGroup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationGroup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationGroup' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationProviderApp$inboundSchema: z.ZodType<
  UpdateInstallationProviderApp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  projectId: z.string(),
  externalRef: z.string().optional(),
  provider: z.string(),
  clientId: z.string(),
  scopes: z.array(z.string()).optional(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationProviderApp$Outbound = {
  id: string;
  projectId: string;
  externalRef?: string | undefined;
  provider: string;
  clientId: string;
  scopes?: Array<string> | undefined;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationProviderApp$outboundSchema: z.ZodType<
  UpdateInstallationProviderApp$Outbound,
  z.ZodTypeDef,
  UpdateInstallationProviderApp
> = z.object({
  id: z.string(),
  projectId: z.string(),
  externalRef: z.string().optional(),
  provider: z.string(),
  clientId: z.string(),
  scopes: z.array(z.string()).optional(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationProviderApp$ {
  /** @deprecated use `UpdateInstallationProviderApp$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationProviderApp$inboundSchema;
  /** @deprecated use `UpdateInstallationProviderApp$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationProviderApp$outboundSchema;
  /** @deprecated use `UpdateInstallationProviderApp$Outbound` instead. */
  export type Outbound = UpdateInstallationProviderApp$Outbound;
}

export function updateInstallationProviderAppToJSON(
  updateInstallationProviderApp: UpdateInstallationProviderApp,
): string {
  return JSON.stringify(
    UpdateInstallationProviderApp$outboundSchema.parse(
      updateInstallationProviderApp,
    ),
  );
}

export function updateInstallationProviderAppFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationProviderApp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationProviderApp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationProviderApp' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsGroup$inboundSchema: z.ZodType<
  UpdateInstallationInstallationsGroup,
  z.ZodTypeDef,
  unknown
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationInstallationsGroup$Outbound = {
  groupRef: string;
  groupName: string;
  projectId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationInstallationsGroup$outboundSchema: z.ZodType<
  UpdateInstallationInstallationsGroup$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationsGroup
> = z.object({
  groupRef: z.string(),
  groupName: z.string(),
  projectId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsGroup$ {
  /** @deprecated use `UpdateInstallationInstallationsGroup$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsGroup$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsGroup$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsGroup$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsGroup$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationsGroup$Outbound;
}

export function updateInstallationInstallationsGroupToJSON(
  updateInstallationInstallationsGroup: UpdateInstallationInstallationsGroup,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsGroup$outboundSchema.parse(
      updateInstallationInstallationsGroup,
    ),
  );
}

export function updateInstallationInstallationsGroupFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationsGroup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsGroup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationsGroup' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConsumer$inboundSchema: z.ZodType<
  UpdateInstallationConsumer,
  z.ZodTypeDef,
  unknown
> = z.object({
  consumerRef: z.string(),
  consumerName: z.string(),
  projectId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationConsumer$Outbound = {
  consumerRef: string;
  consumerName: string;
  projectId: string;
  createTime: string;
  updateTime?: string | undefined;
};

/** @internal */
export const UpdateInstallationConsumer$outboundSchema: z.ZodType<
  UpdateInstallationConsumer$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConsumer
> = z.object({
  consumerRef: z.string(),
  consumerName: z.string(),
  projectId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConsumer$ {
  /** @deprecated use `UpdateInstallationConsumer$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConsumer$inboundSchema;
  /** @deprecated use `UpdateInstallationConsumer$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConsumer$outboundSchema;
  /** @deprecated use `UpdateInstallationConsumer$Outbound` instead. */
  export type Outbound = UpdateInstallationConsumer$Outbound;
}

export function updateInstallationConsumerToJSON(
  updateInstallationConsumer: UpdateInstallationConsumer,
): string {
  return JSON.stringify(
    UpdateInstallationConsumer$outboundSchema.parse(updateInstallationConsumer),
  );
}

export function updateInstallationConsumerFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConsumer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConsumer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConsumer' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationAuthScheme$inboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationAuthScheme
> = z.nativeEnum(UpdateInstallationAuthScheme);

/** @internal */
export const UpdateInstallationAuthScheme$outboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationAuthScheme
> = UpdateInstallationAuthScheme$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationAuthScheme$ {
  /** @deprecated use `UpdateInstallationAuthScheme$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationAuthScheme$inboundSchema;
  /** @deprecated use `UpdateInstallationAuthScheme$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationAuthScheme$outboundSchema;
}

/** @internal */
export const UpdateInstallationStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationStatus
> = z.nativeEnum(UpdateInstallationStatus);

/** @internal */
export const UpdateInstallationStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateInstallationStatus
> = UpdateInstallationStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationStatus$ {
  /** @deprecated use `UpdateInstallationStatus$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationStatus$inboundSchema;
  /** @deprecated use `UpdateInstallationStatus$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationStatus$outboundSchema;
}

/** @internal */
export const UpdateInstallationAccessToken$inboundSchema: z.ZodType<
  UpdateInstallationAccessToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  issuedAt: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  expiresAt: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationAccessToken$Outbound = {
  token: string;
  issuedAt?: string | undefined;
  expiresAt?: string | undefined;
};

/** @internal */
export const UpdateInstallationAccessToken$outboundSchema: z.ZodType<
  UpdateInstallationAccessToken$Outbound,
  z.ZodTypeDef,
  UpdateInstallationAccessToken
> = z.object({
  token: z.string(),
  issuedAt: z.date().transform(v => v.toISOString()).optional(),
  expiresAt: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationAccessToken$ {
  /** @deprecated use `UpdateInstallationAccessToken$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationAccessToken$inboundSchema;
  /** @deprecated use `UpdateInstallationAccessToken$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationAccessToken$outboundSchema;
  /** @deprecated use `UpdateInstallationAccessToken$Outbound` instead. */
  export type Outbound = UpdateInstallationAccessToken$Outbound;
}

export function updateInstallationAccessTokenToJSON(
  updateInstallationAccessToken: UpdateInstallationAccessToken,
): string {
  return JSON.stringify(
    UpdateInstallationAccessToken$outboundSchema.parse(
      updateInstallationAccessToken,
    ),
  );
}

export function updateInstallationAccessTokenFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationAccessToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationAccessToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationAccessToken' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationRefreshToken$inboundSchema: z.ZodType<
  UpdateInstallationRefreshToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  issuedAt: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  expiresAt: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
});

/** @internal */
export type UpdateInstallationRefreshToken$Outbound = {
  token: string;
  issuedAt?: string | undefined;
  expiresAt?: string | undefined;
};

/** @internal */
export const UpdateInstallationRefreshToken$outboundSchema: z.ZodType<
  UpdateInstallationRefreshToken$Outbound,
  z.ZodTypeDef,
  UpdateInstallationRefreshToken
> = z.object({
  token: z.string(),
  issuedAt: z.date().transform(v => v.toISOString()).optional(),
  expiresAt: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationRefreshToken$ {
  /** @deprecated use `UpdateInstallationRefreshToken$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationRefreshToken$inboundSchema;
  /** @deprecated use `UpdateInstallationRefreshToken$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationRefreshToken$outboundSchema;
  /** @deprecated use `UpdateInstallationRefreshToken$Outbound` instead. */
  export type Outbound = UpdateInstallationRefreshToken$Outbound;
}

export function updateInstallationRefreshTokenToJSON(
  updateInstallationRefreshToken: UpdateInstallationRefreshToken,
): string {
  return JSON.stringify(
    UpdateInstallationRefreshToken$outboundSchema.parse(
      updateInstallationRefreshToken,
    ),
  );
}

export function updateInstallationRefreshTokenFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationRefreshToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationRefreshToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationRefreshToken' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationOAuth2AuthorizationCodeToken$inboundSchema:
  z.ZodType<
    UpdateInstallationOAuth2AuthorizationCodeToken,
    z.ZodTypeDef,
    unknown
  > = z.object({
    accessToken: z.lazy(() => UpdateInstallationAccessToken$inboundSchema)
      .optional(),
    refreshToken: z.lazy(() => UpdateInstallationRefreshToken$inboundSchema)
      .optional(),
    scopes: z.array(z.string()).optional(),
  });

/** @internal */
export type UpdateInstallationOAuth2AuthorizationCodeToken$Outbound = {
  accessToken?: UpdateInstallationAccessToken$Outbound | undefined;
  refreshToken?: UpdateInstallationRefreshToken$Outbound | undefined;
  scopes?: Array<string> | undefined;
};

/** @internal */
export const UpdateInstallationOAuth2AuthorizationCodeToken$outboundSchema:
  z.ZodType<
    UpdateInstallationOAuth2AuthorizationCodeToken$Outbound,
    z.ZodTypeDef,
    UpdateInstallationOAuth2AuthorizationCodeToken
  > = z.object({
    accessToken: z.lazy(() => UpdateInstallationAccessToken$outboundSchema)
      .optional(),
    refreshToken: z.lazy(() => UpdateInstallationRefreshToken$outboundSchema)
      .optional(),
    scopes: z.array(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationOAuth2AuthorizationCodeToken$ {
  /** @deprecated use `UpdateInstallationOAuth2AuthorizationCodeToken$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationOAuth2AuthorizationCodeToken$inboundSchema;
  /** @deprecated use `UpdateInstallationOAuth2AuthorizationCodeToken$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationOAuth2AuthorizationCodeToken$outboundSchema;
  /** @deprecated use `UpdateInstallationOAuth2AuthorizationCodeToken$Outbound` instead. */
  export type Outbound =
    UpdateInstallationOAuth2AuthorizationCodeToken$Outbound;
}

export function updateInstallationOAuth2AuthorizationCodeTokenToJSON(
  updateInstallationOAuth2AuthorizationCodeToken:
    UpdateInstallationOAuth2AuthorizationCodeToken,
): string {
  return JSON.stringify(
    UpdateInstallationOAuth2AuthorizationCodeToken$outboundSchema.parse(
      updateInstallationOAuth2AuthorizationCodeToken,
    ),
  );
}

export function updateInstallationOAuth2AuthorizationCodeTokenFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateInstallationOAuth2AuthorizationCodeToken,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationOAuth2AuthorizationCodeToken$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateInstallationOAuth2AuthorizationCodeToken' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationConnection$inboundSchema: z.ZodType<
  UpdateInstallationConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  projectId: z.string(),
  provider: z.string(),
  providerApp: z.lazy(() => UpdateInstallationProviderApp$inboundSchema)
    .optional(),
  group: z.lazy(() => UpdateInstallationInstallationsGroup$inboundSchema),
  consumer: z.lazy(() => UpdateInstallationConsumer$inboundSchema),
  providerWorkspaceRef: z.string().optional(),
  providerConsumerRef: z.string().optional(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  authScheme: UpdateInstallationAuthScheme$inboundSchema,
  status: UpdateInstallationStatus$inboundSchema,
  oauth2AuthorizationCode: z.lazy(() =>
    UpdateInstallationOAuth2AuthorizationCodeToken$inboundSchema
  ).optional(),
  apiKey: z.string().optional(),
});

/** @internal */
export type UpdateInstallationConnection$Outbound = {
  id: string;
  projectId: string;
  provider: string;
  providerApp?: UpdateInstallationProviderApp$Outbound | undefined;
  group: UpdateInstallationInstallationsGroup$Outbound;
  consumer: UpdateInstallationConsumer$Outbound;
  providerWorkspaceRef?: string | undefined;
  providerConsumerRef?: string | undefined;
  createTime: string;
  updateTime?: string | undefined;
  authScheme: string;
  status: string;
  oauth2AuthorizationCode?:
    | UpdateInstallationOAuth2AuthorizationCodeToken$Outbound
    | undefined;
  apiKey?: string | undefined;
};

/** @internal */
export const UpdateInstallationConnection$outboundSchema: z.ZodType<
  UpdateInstallationConnection$Outbound,
  z.ZodTypeDef,
  UpdateInstallationConnection
> = z.object({
  id: z.string(),
  projectId: z.string(),
  provider: z.string(),
  providerApp: z.lazy(() => UpdateInstallationProviderApp$outboundSchema)
    .optional(),
  group: z.lazy(() => UpdateInstallationInstallationsGroup$outboundSchema),
  consumer: z.lazy(() => UpdateInstallationConsumer$outboundSchema),
  providerWorkspaceRef: z.string().optional(),
  providerConsumerRef: z.string().optional(),
  createTime: z.date().transform(v => v.toISOString()),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
  authScheme: UpdateInstallationAuthScheme$outboundSchema,
  status: UpdateInstallationStatus$outboundSchema,
  oauth2AuthorizationCode: z.lazy(() =>
    UpdateInstallationOAuth2AuthorizationCodeToken$outboundSchema
  ).optional(),
  apiKey: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationConnection$ {
  /** @deprecated use `UpdateInstallationConnection$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationConnection$inboundSchema;
  /** @deprecated use `UpdateInstallationConnection$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationConnection$outboundSchema;
  /** @deprecated use `UpdateInstallationConnection$Outbound` instead. */
  export type Outbound = UpdateInstallationConnection$Outbound;
}

export function updateInstallationConnectionToJSON(
  updateInstallationConnection: UpdateInstallationConnection,
): string {
  return JSON.stringify(
    UpdateInstallationConnection$outboundSchema.parse(
      updateInstallationConnection,
    ),
  );
}

export function updateInstallationConnectionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationConnection' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsBaseProxyConfig$inboundSchema:
  z.ZodType<
    UpdateInstallationInstallationsBaseProxyConfig,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: z.boolean().optional(),
  });

/** @internal */
export type UpdateInstallationInstallationsBaseProxyConfig$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const UpdateInstallationInstallationsBaseProxyConfig$outboundSchema:
  z.ZodType<
    UpdateInstallationInstallationsBaseProxyConfig$Outbound,
    z.ZodTypeDef,
    UpdateInstallationInstallationsBaseProxyConfig
  > = z.object({
    enabled: z.boolean().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsBaseProxyConfig$ {
  /** @deprecated use `UpdateInstallationInstallationsBaseProxyConfig$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsBaseProxyConfig$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsBaseProxyConfig$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsBaseProxyConfig$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsBaseProxyConfig$Outbound` instead. */
  export type Outbound =
    UpdateInstallationInstallationsBaseProxyConfig$Outbound;
}

export function updateInstallationInstallationsBaseProxyConfigToJSON(
  updateInstallationInstallationsBaseProxyConfig:
    UpdateInstallationInstallationsBaseProxyConfig,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsBaseProxyConfig$outboundSchema.parse(
      updateInstallationInstallationsBaseProxyConfig,
    ),
  );
}

export function updateInstallationInstallationsBaseProxyConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateInstallationInstallationsBaseProxyConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsBaseProxyConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateInstallationInstallationsBaseProxyConfig' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsConfigContent$inboundSchema:
  z.ZodType<
    UpdateInstallationInstallationsConfigContent,
    z.ZodTypeDef,
    unknown
  > = z.object({
    provider: z.string(),
    read: z.any().optional(),
    write: z.any().optional(),
    proxy: z.lazy(() =>
      UpdateInstallationInstallationsBaseProxyConfig$inboundSchema
    ).optional(),
  });

/** @internal */
export type UpdateInstallationInstallationsConfigContent$Outbound = {
  provider: string;
  read?: any | undefined;
  write?: any | undefined;
  proxy?: UpdateInstallationInstallationsBaseProxyConfig$Outbound | undefined;
};

/** @internal */
export const UpdateInstallationInstallationsConfigContent$outboundSchema:
  z.ZodType<
    UpdateInstallationInstallationsConfigContent$Outbound,
    z.ZodTypeDef,
    UpdateInstallationInstallationsConfigContent
  > = z.object({
    provider: z.string(),
    read: z.any().optional(),
    write: z.any().optional(),
    proxy: z.lazy(() =>
      UpdateInstallationInstallationsBaseProxyConfig$outboundSchema
    ).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsConfigContent$ {
  /** @deprecated use `UpdateInstallationInstallationsConfigContent$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsConfigContent$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsConfigContent$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsConfigContent$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsConfigContent$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationsConfigContent$Outbound;
}

export function updateInstallationInstallationsConfigContentToJSON(
  updateInstallationInstallationsConfigContent:
    UpdateInstallationInstallationsConfigContent,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsConfigContent$outboundSchema.parse(
      updateInstallationInstallationsConfigContent,
    ),
  );
}

export function updateInstallationInstallationsConfigContentFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateInstallationInstallationsConfigContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsConfigContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateInstallationInstallationsConfigContent' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallationsConfig$inboundSchema: z.ZodType<
  UpdateInstallationInstallationsConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  revisionId: z.string(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  createdBy: z.string(),
  content: z.lazy(() =>
    UpdateInstallationInstallationsConfigContent$inboundSchema
  ),
});

/** @internal */
export type UpdateInstallationInstallationsConfig$Outbound = {
  id: string;
  revisionId: string;
  createTime: string;
  createdBy: string;
  content: UpdateInstallationInstallationsConfigContent$Outbound;
};

/** @internal */
export const UpdateInstallationInstallationsConfig$outboundSchema: z.ZodType<
  UpdateInstallationInstallationsConfig$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallationsConfig
> = z.object({
  id: z.string(),
  revisionId: z.string(),
  createTime: z.date().transform(v => v.toISOString()),
  createdBy: z.string(),
  content: z.lazy(() =>
    UpdateInstallationInstallationsConfigContent$outboundSchema
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallationsConfig$ {
  /** @deprecated use `UpdateInstallationInstallationsConfig$inboundSchema` instead. */
  export const inboundSchema =
    UpdateInstallationInstallationsConfig$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsConfig$outboundSchema` instead. */
  export const outboundSchema =
    UpdateInstallationInstallationsConfig$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallationsConfig$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallationsConfig$Outbound;
}

export function updateInstallationInstallationsConfigToJSON(
  updateInstallationInstallationsConfig: UpdateInstallationInstallationsConfig,
): string {
  return JSON.stringify(
    UpdateInstallationInstallationsConfig$outboundSchema.parse(
      updateInstallationInstallationsConfig,
    ),
  );
}

export function updateInstallationInstallationsConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallationsConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateInstallationInstallationsConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallationsConfig' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationInstallation$inboundSchema: z.ZodType<
  UpdateInstallationInstallation,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  projectId: z.string(),
  integrationId: z.string(),
  group: z.lazy(() => UpdateInstallationGroup$inboundSchema).optional(),
  healthStatus: z.string(),
  connection: z.lazy(() => UpdateInstallationConnection$inboundSchema),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  createdBy: z.string(),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  config: z.lazy(() => UpdateInstallationInstallationsConfig$inboundSchema),
});

/** @internal */
export type UpdateInstallationInstallation$Outbound = {
  id: string;
  projectId: string;
  integrationId: string;
  group?: UpdateInstallationGroup$Outbound | undefined;
  healthStatus: string;
  connection: UpdateInstallationConnection$Outbound;
  createTime: string;
  createdBy: string;
  updateTime?: string | undefined;
  config: UpdateInstallationInstallationsConfig$Outbound;
};

/** @internal */
export const UpdateInstallationInstallation$outboundSchema: z.ZodType<
  UpdateInstallationInstallation$Outbound,
  z.ZodTypeDef,
  UpdateInstallationInstallation
> = z.object({
  id: z.string(),
  projectId: z.string(),
  integrationId: z.string(),
  group: z.lazy(() => UpdateInstallationGroup$outboundSchema).optional(),
  healthStatus: z.string(),
  connection: z.lazy(() => UpdateInstallationConnection$outboundSchema),
  createTime: z.date().transform(v => v.toISOString()),
  createdBy: z.string(),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
  config: z.lazy(() => UpdateInstallationInstallationsConfig$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationInstallation$ {
  /** @deprecated use `UpdateInstallationInstallation$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationInstallation$inboundSchema;
  /** @deprecated use `UpdateInstallationInstallation$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationInstallation$outboundSchema;
  /** @deprecated use `UpdateInstallationInstallation$Outbound` instead. */
  export type Outbound = UpdateInstallationInstallation$Outbound;
}

export function updateInstallationInstallationToJSON(
  updateInstallationInstallation: UpdateInstallationInstallation,
): string {
  return JSON.stringify(
    UpdateInstallationInstallation$outboundSchema.parse(
      updateInstallationInstallation,
    ),
  );
}

export function updateInstallationInstallationFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationInstallation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationInstallation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationInstallation' from JSON`,
  );
}

/** @internal */
export const UpdateInstallationResponse$inboundSchema: z.ZodType<
  UpdateInstallationResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateInstallationInstallation$inboundSchema),
  z.lazy(() => UpdateInstallationAPIProblem$inboundSchema),
]);

/** @internal */
export type UpdateInstallationResponse$Outbound =
  | UpdateInstallationInstallation$Outbound
  | UpdateInstallationAPIProblem$Outbound;

/** @internal */
export const UpdateInstallationResponse$outboundSchema: z.ZodType<
  UpdateInstallationResponse$Outbound,
  z.ZodTypeDef,
  UpdateInstallationResponse
> = z.union([
  z.lazy(() => UpdateInstallationInstallation$outboundSchema),
  z.lazy(() => UpdateInstallationAPIProblem$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateInstallationResponse$ {
  /** @deprecated use `UpdateInstallationResponse$inboundSchema` instead. */
  export const inboundSchema = UpdateInstallationResponse$inboundSchema;
  /** @deprecated use `UpdateInstallationResponse$outboundSchema` instead. */
  export const outboundSchema = UpdateInstallationResponse$outboundSchema;
  /** @deprecated use `UpdateInstallationResponse$Outbound` instead. */
  export type Outbound = UpdateInstallationResponse$Outbound;
}

export function updateInstallationResponseToJSON(
  updateInstallationResponse: UpdateInstallationResponse,
): string {
  return JSON.stringify(
    UpdateInstallationResponse$outboundSchema.parse(updateInstallationResponse),
  );
}

export function updateInstallationResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateInstallationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateInstallationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateInstallationResponse' from JSON`,
  );
}
